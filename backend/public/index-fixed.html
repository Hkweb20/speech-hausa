<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hausa Speech-to-Text App</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      color: #333;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
      color: white;
    }

    .header h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }

    .header p {
      font-size: 1.1rem;
      opacity: 0.9;
    }

    .auth-section {
      background: white;
      border-radius: 15px;
      padding: 30px;
      margin-bottom: 30px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }

    .auth-tabs {
      display: flex;
      margin-bottom: 30px;
      border-bottom: 2px solid #f0f0f0;
    }

    .auth-tab {
      flex: 1;
      padding: 15px;
      text-align: center;
      cursor: pointer;
      border: none;
      background: none;
      font-size: 1.1rem;
      font-weight: 500;
      color: #666;
      transition: all 0.3s ease;
    }

    .auth-tab.active {
      color: #667eea;
      border-bottom: 3px solid #667eea;
    }

    .auth-form {
      display: none;
    }

    .auth-form.active {
      display: block;
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-group label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: #333;
    }

    .form-group input {
      width: 100%;
      padding: 12px 15px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 1rem;
      transition: border-color 0.3s ease;
    }

    .form-group input:focus {
      outline: none;
      border-color: #667eea;
    }

    .btn {
      width: 100%;
      padding: 15px;
      border: none;
      border-radius: 8px;
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-bottom: 15px;
    }

    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
    }

    .btn-secondary {
      background: #f8f9fa;
      color: #666;
      border: 2px solid #e0e0e0;
    }

    .btn-secondary:hover {
      background: #e9ecef;
    }

    .user-info {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 20px;
      display: none;
    }

    .user-info.active {
      display: block;
    }

    .user-details {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .user-name {
      font-size: 1.2rem;
      font-weight: 600;
      color: #333;
    }

    .user-tier {
      background: #667eea;
      color: white;
      padding: 5px 15px;
      border-radius: 20px;
      font-size: 0.9rem;
      text-transform: uppercase;
    }

    .user-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      margin-top: 15px;
    }

    .stat-item {
      text-align: center;
      padding: 10px;
      background: white;
      border-radius: 8px;
    }

    .stat-value {
      font-size: 1.5rem;
      font-weight: 600;
      color: #667eea;
    }

    .stat-label {
      font-size: 0.9rem;
      color: #666;
      margin-top: 5px;
    }

    /* Progress bars for limits */
    .limit-progress {
      margin-top: 10px;
    }

    .progress-bar {
      width: 100%;
      height: 8px;
      background: #e0e0e0;
      border-radius: 4px;
      overflow: hidden;
      margin-top: 5px;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #667eea, #764ba2);
      transition: width 0.3s ease;
    }

    .progress-fill.warning {
      background: linear-gradient(90deg, #ffa500, #ff8c00);
    }

    .progress-fill.danger {
      background: linear-gradient(90deg, #ff6b6b, #ee5a52);
    }

    .limit-text {
      font-size: 0.8rem;
      color: #666;
      margin-top: 3px;
    }

    .limit-text.warning {
      color: #ff8c00;
    }

    .limit-text.danger {
      color: #ee5a52;
    }

    /* File upload limits display */
    .upload-limits {
      background: #f8f9fa;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      padding: 15px;
      margin-top: 15px;
    }

    .upload-limits h4 {
      color: #333;
      margin-bottom: 10px;
      font-size: 1rem;
    }

    .limit-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      font-size: 0.9rem;
    }

    .limit-item:last-child {
      margin-bottom: 0;
    }

    .limit-label {
      color: #666;
    }

    .limit-value {
      font-weight: 600;
      color: #333;
    }

    .main-content {
      display: none;
    }

    .main-content.active {
      display: block;
    }

    .feature-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .feature-card {
      background: white;
      border-radius: 15px;
      padding: 25px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
      transition: transform 0.3s ease;
    }

    .feature-card:hover {
      transform: translateY(-5px);
    }

    .feature-card h3 {
      color: #333;
      margin-bottom: 15px;
      font-size: 1.3rem;
    }

    .feature-card p {
      color: #666;
      margin-bottom: 20px;
      line-height: 1.6;
    }

    .upload-area {
      border: 2px dashed #e0e0e0;
      border-radius: 10px;
      padding: 30px;
      text-align: center;
      margin-bottom: 20px;
      transition: border-color 0.3s ease;
    }

    .upload-area:hover {
      border-color: #667eea;
    }

    .upload-area.dragover {
      border-color: #667eea;
      background: #f8f9ff;
    }

    .file-input {
      display: none;
    }

    .upload-btn {
      background: #667eea;
      color: white;
      padding: 12px 25px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1rem;
      margin-bottom: 15px;
    }

    .result-area {
      background: #f8f9fa;
      border-radius: 10px;
      padding: 20px;
      margin-top: 20px;
      min-height: 100px;
    }

    .transcript-text {
      font-size: 1.1rem;
      line-height: 1.6;
      color: #333;
    }

    .loading {
      text-align: center;
      color: #667eea;
      font-style: italic;
    }

    .error {
      color: #e74c3c;
      background: #fdf2f2;
      padding: 15px;
      border-radius: 8px;
      margin-top: 15px;
    }

    .success {
      color: #27ae60;
      background: #f0f9f4;
      padding: 15px;
      border-radius: 8px;
      margin-top: 15px;
    }

    .log {
      background: #1a1a1a;
      color: #00ff00;
      padding: 15px;
      border-radius: 8px;
      height: 200px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
      margin-top: 20px;
    }

    .hidden {
      display: none !important;
    }

    .points-display {
      background: linear-gradient(135deg, #ffd700, #ffed4e);
      color: #333;
      padding: 10px 20px;
      border-radius: 25px;
      font-weight: 600;
      display: inline-block;
      margin-left: 15px;
    }

    /* AI Features Styles */
    .ai-buttons {
      display: flex;
      gap: 10px;
      margin-top: 15px;
      flex-wrap: wrap;
    }

    .ai-btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 6px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .ai-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }

    .ai-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .ai-btn.loading {
      background: #ffa500;
    }

    /* Modal Styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
    }

    .modal.active {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .modal-content {
      background: white;
      border-radius: 15px;
      padding: 30px;
      max-width: 90%;
      max-height: 90%;
      overflow-y: auto;
      box-shadow: 0 20px 40px rgba(0,0,0,0.3);
      position: relative;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 2px solid #f0f0f0;
    }

    .modal-title {
      font-size: 1.5rem;
      font-weight: 600;
      color: #333;
    }

    .close-btn {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: #666;
      padding: 5px;
    }

    .close-btn:hover {
      color: #333;
    }

    .ai-result {
      background: #f8f9fa;
      border-radius: 10px;
      padding: 20px;
      margin-bottom: 15px;
      border-left: 4px solid #667eea;
    }

    .ai-result h4 {
      color: #667eea;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }

    .ai-result-text {
      font-size: 1rem;
      line-height: 1.6;
      color: #333;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .copy-btn {
      background: #28a745;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      margin-top: 10px;
      transition: all 0.3s ease;
    }

    .copy-btn:hover {
      background: #218838;
      transform: translateY(-1px);
    }

    .copy-btn.copied {
      background: #6c757d;
    }

    .platform-tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .platform-tab {
      background: #f8f9fa;
      border: 2px solid #e0e0e0;
      color: #666;
      padding: 8px 15px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.3s ease;
    }

    .platform-tab.active {
      background: #667eea;
      color: white;
      border-color: #667eea;
    }

    .platform-content {
      display: none;
    }

    .platform-content.active {
      display: block;
    }

    .usage-info {
      background: #e3f2fd;
      border: 1px solid #bbdefb;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
      font-size: 0.9rem;
      color: #1565c0;
    }

    .usage-info.warning {
      background: #fff3e0;
      border-color: #ffcc02;
      color: #e65100;
    }

    .usage-info.error {
      background: #ffebee;
      border-color: #f44336;
      color: #c62828;
    }

    @media (max-width: 768px) {
      .container {
        padding: 10px;
      }
      
      .header h1 {
        font-size: 2rem;
      }
      
      .feature-grid {
        grid-template-columns: 1fr;
      }
      
      .user-details {
        flex-direction: column;
        gap: 10px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üé§ Hausa Speech-to-Text</h1>
      <p>Convert your Hausa audio to text with AI-powered transcription</p>
    </div>

    <!-- Authentication Section -->
    <div class="auth-section" id="authSection">
      <div class="auth-tabs">
        <button class="auth-tab active" id="loginTab">Login</button>
        <button class="auth-tab" id="registerTab">Register</button>
      </div>

      <!-- Login Form -->
      <div class="auth-form active" id="loginForm">
        <form id="loginFormElement">
          <div class="form-group">
            <label for="loginEmail">Email</label>
            <input type="email" id="loginEmail" required>
          </div>
          <div class="form-group">
            <label for="loginPassword">Password</label>
            <input type="password" id="loginPassword" required>
          </div>
          <button type="submit" class="btn btn-primary">Login</button>
        </form>
      </div>

      <!-- Register Form -->
      <div class="auth-form" id="registerForm">
        <form id="registerFormElement">
          <div class="form-group">
            <label for="registerName">Full Name</label>
            <input type="text" id="registerName" required>
          </div>
          <div class="form-group">
            <label for="registerEmail">Email</label>
            <input type="email" id="registerEmail" required>
          </div>
          <div class="form-group">
            <label for="registerPassword">Password</label>
            <input type="password" id="registerPassword" required minlength="8">
          </div>
          <button type="submit" class="btn btn-primary">Register</button>
        </form>
      </div>
    </div>

    <!-- User Info Section -->
    <div class="user-info" id="userInfo">
      <div class="user-details">
        <div>
          <div class="user-name" id="userName">Welcome!</div>
          <div class="user-tier" id="userTier">Free</div>
        </div>
        <div>
          <span class="points-display" id="pointsDisplay">0 Points</span>
          <button class="btn btn-secondary" id="logoutBtn">Logout</button>
        </div>
      </div>
      <div class="user-stats" id="userStats">
        <!-- Stats will be populated by JavaScript -->
      </div>
      
          <!-- File Upload Limits -->
          <div class="upload-limits" id="uploadLimits" style="display: none;">
            <h4>üìÅ File Upload Limits</h4>
            <div class="limit-item">
              <span class="limit-label">Daily Uploads:</span>
              <span class="limit-value" id="dailyUploads">0/2</span>
            </div>
            <div class="limit-progress">
              <div class="progress-bar">
                <div class="progress-fill" id="uploadProgress" style="width: 0%"></div>
              </div>
              <div class="limit-text" id="uploadLimitText">2 uploads remaining today</div>
            </div>
            <div class="limit-item">
              <span class="limit-label">Max File Duration:</span>
              <span class="limit-value" id="maxFileDuration">3 minutes</span>
            </div>
            <div class="limit-item">
              <span class="limit-label">Subscription:</span>
              <span class="limit-value" id="subscriptionTier">Free</span>
            </div>
          </div>
          
        <!-- Live Recording Limits -->
        <div class="upload-limits" id="liveRecordingLimits" style="display: none;">
          <h4>üéôÔ∏è Live Recording Limits</h4>
          <div class="limit-item">
            <span class="limit-label">Daily Minutes:</span>
            <span class="limit-value" id="dailyLiveRecordingMinutes">0/5</span>
          </div>
          <div class="limit-progress">
            <div class="progress-bar">
              <div class="progress-fill" id="liveRecordingProgress" style="width: 0%"></div>
            </div>
            <div class="limit-text" id="liveRecordingLimitText">5 minutes remaining today</div>
          </div>
          <div class="limit-item">
            <span class="limit-label">Subscription:</span>
            <span class="limit-value" id="liveRecordingSubscriptionTier">Free</span>
          </div>
        </div>

        <!-- Real-time Streaming Limits -->
        <div class="upload-limits" id="realTimeStreamingLimits" style="display: none;">
          <h4>‚ö° Real-time Streaming Limits</h4>
          <div class="limit-item">
            <span class="limit-label">Daily Minutes:</span>
            <span class="limit-value" id="dailyRealTimeStreamingMinutes">0/3</span>
          </div>
          <div class="limit-progress">
            <div class="progress-bar">
              <div class="progress-fill" id="realTimeStreamingProgress" style="width: 0%"></div>
            </div>
            <div class="limit-text" id="realTimeStreamingLimitText">3 minutes remaining today</div>
          </div>
          <div class="limit-item">
            <span class="limit-label">Subscription:</span>
            <span class="limit-value" id="realTimeStreamingSubscriptionTier">Free</span>
          </div>
        </div>

        <!-- Translation Limits -->
        <div class="upload-limits" id="translationLimits" style="display: none;">
          <h4>üåç Translation Limits</h4>
          <div class="limit-item">
            <span class="limit-label">Daily Minutes:</span>
            <span class="limit-value" id="dailyTranslationMinutes">0/30</span>
          </div>
          <div class="limit-progress">
            <div class="progress-bar">
              <div class="progress-fill" id="translationProgress" style="width: 0%"></div>
            </div>
            <div class="limit-text" id="translationLimitText">30 minutes remaining today</div>
          </div>
          <div class="limit-item">
            <span class="limit-label">Subscription:</span>
            <span class="limit-value" id="translationSubscriptionTier">Premium</span>
          </div>
        </div>

        <!-- AI Features Limits -->
        <div class="upload-limits" id="aiLimits" style="display: none;">
          <h4>ü§ñ AI Features Limits</h4>
          <div class="limit-item">
            <span class="limit-label">Daily Requests:</span>
            <span class="limit-value" id="dailyAIRequests">0/5</span>
          </div>
          <div class="limit-progress">
            <div class="progress-bar">
              <div class="progress-fill" id="aiProgress" style="width: 0%"></div>
            </div>
            <div class="limit-text" id="aiLimitText">5 requests remaining today</div>
          </div>
          <div class="limit-item">
            <span class="limit-label">Monthly Requests:</span>
            <span class="limit-value" id="monthlyAIRequests">0/150</span>
          </div>
          <div class="limit-item">
            <span class="limit-label">Available Features:</span>
            <span class="limit-value" id="availableAIFeatures">Basic punctuation</span>
          </div>
          <div class="limit-item">
            <span class="limit-label">Subscription:</span>
            <span class="limit-value" id="aiSubscriptionTier">Free</span>
          </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="main-content" id="mainContent">
      <div class="feature-grid">
        <!-- File Upload Feature -->
        <div class="feature-card">
          <h3>üìÅ Upload Audio File</h3>
          <p>Upload an audio file and get it transcribed and translated. Supports MP3, WAV, WebM, and more formats.</p>
          
          <!-- Language Selection -->
          <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
            <h4 style="margin-bottom: 15px; color: #333;">Language Selection</h4>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
              <div class="form-group">
                <label for="sourceLanguage">Source Language (Audio Language)</label>
                <select id="sourceLanguage" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                  <option value="ha-NG">Hausa (Default)</option>
                  <option value="yo-NG">Yoruba</option>
                  <option value="ig-NG">Igbo</option>
                  <option value="ar-SA">Arabic</option>
                </select>
              </div>
              <div class="form-group">
                <label for="targetLanguage">Target Language (Translation)</label>
                <select id="targetLanguage" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                  <option value="ha-NG">Hausa</option>
                  <option value="yo-NG">Yoruba</option>
                  <option value="ig-NG">Igbo</option>
                  <option value="ar-SA">Arabic</option>
                  <option value="en-US">English</option>
                </select>
              </div>
            </div>
            <div style="margin-top: 10px; font-size: 0.9rem; color: #666;">
              <strong>Note:</strong> If source and target languages are the same, only transcription will be performed.
            </div>
          </div>
          
          <!-- Upload Limits Warning -->
          <div id="uploadLimitsWarning" class="usage-info" style="display: none; margin-bottom: 15px;">
            <strong>üìã Upload Limits:</strong>
            <div id="uploadLimitsText">Loading limits...</div>
          </div>
          
          <div class="upload-area" id="uploadArea">
            <p>Drag & drop your audio file here or click to browse</p>
            <input type="file" id="fileInput" class="file-input" accept="audio/*">
            <button class="upload-btn" id="uploadBtn">Choose File</button>
          </div>
          <div class="result-area" id="uploadResult">
            <div class="transcript-text">Your transcription and translation will appear here...</div>
            
            <!-- AI Features Warning -->
            <div id="uploadAiLimitsWarning" class="usage-info" style="display: none; margin-bottom: 15px;">
              <strong>ü§ñ AI Features:</strong>
              <div id="uploadAiLimitsText">Loading AI limits...</div>
            </div>
            
            <div class="ai-buttons" id="uploadAiButtons" style="display: none;">
              <button class="ai-btn" onclick="summarizeText('uploadResult')">üìù Summarize</button>
              <button class="ai-btn" onclick="formatText('uploadResult', 'facebook')">üìò Facebook</button>
              <button class="ai-btn" onclick="formatText('uploadResult', 'whatsapp')">üí¨ WhatsApp</button>
              <button class="ai-btn" onclick="formatText('uploadResult', 'x')">üê¶ X</button>
              <button class="ai-btn" onclick="formatText('uploadResult', 'instagram')">üì∑ Instagram</button>
              <button class="ai-btn" onclick="formatText('uploadResult', 'telegram')">‚úàÔ∏è Telegram</button>
              <button class="ai-btn" onclick="formatAllText('uploadResult')">üåê All Platforms</button>
            </div>
          </div>
        </div>

        <!-- Live Recording Feature -->
        <div class="feature-card">
          <h3>üéôÔ∏è Live Recording</h3>
          <p>Record directly from your microphone and get real-time transcription and translation.</p>
          
          <!-- Language Selection -->
          <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
            <h4 style="margin-bottom: 15px; color: #333;">Language Selection</h4>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
              <div class="form-group">
                <label for="recordSourceLanguage">Source Language (Speaking Language)</label>
                <select id="recordSourceLanguage" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                  <option value="ha-NG">üá≥üá¨ Hausa (Default)</option>
                  <option value="yo-NG">üá≥üá¨ Yoruba</option>
                  <option value="ig-NG">üá≥üá¨ Igbo</option>
                  <option value="ar-SA">üá∏üá¶ Arabic</option>
                </select>
              </div>
              <div class="form-group">
                <label for="recordTargetLanguage">Target Language (Translation)</label>
                <select id="recordTargetLanguage" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                  <option value="ha-NG">üá≥üá¨ Hausa</option>
                  <option value="yo-NG">üá≥üá¨ Yoruba</option>
                  <option value="ig-NG">üá≥üá¨ Igbo</option>
                  <option value="ar-SA">üá∏üá¶ Arabic</option>
                  <option value="en-US">üá∫üá∏ English</option>
                </select>
              </div>
            </div>
            <div style="margin-top: 10px; font-size: 0.9rem; color: #666;">
              <strong>Note:</strong> If source and target languages are the same, only transcription will be performed.
            </div>
          </div>
          
          <!-- Live Recording Limits Warning -->
          <div id="liveRecordingLimitsWarning" class="usage-info" style="display: none; margin-bottom: 15px;">
            <strong>üéôÔ∏è Live Recording Limits:</strong>
            <div id="liveRecordingLimitsText">Loading limits...</div>
          </div>
          
          <div style="text-align: center; margin-bottom: 20px;">
            <button class="btn btn-primary" id="recordBtn">Start Recording</button>
            <button class="btn btn-secondary" id="stopBtn" disabled>Stop Recording</button>
          </div>
          <audio id="playback" controls style="width: 100%; margin-bottom: 15px;"></audio>
          <div class="result-area" id="recordResult">
            <div class="transcript-text">Your live transcription and translation will appear here...</div>
            
            <!-- AI Features Warning -->
            <div id="recordAiLimitsWarning" class="usage-info" style="display: none; margin-bottom: 15px;">
              <strong>ü§ñ AI Features:</strong>
              <div id="recordAiLimitsText">Loading AI limits...</div>
            </div>
            
            <div class="ai-buttons" id="recordAiButtons" style="display: none;">
              <button class="ai-btn" onclick="summarizeText('recordResult')">üìù Summarize</button>
              <button class="ai-btn" onclick="formatText('recordResult', 'facebook')">üìò Facebook</button>
              <button class="ai-btn" onclick="formatText('recordResult', 'whatsapp')">üí¨ WhatsApp</button>
              <button class="ai-btn" onclick="formatText('recordResult', 'x')">üê¶ X</button>
              <button class="ai-btn" onclick="formatText('recordResult', 'instagram')">üì∑ Instagram</button>
              <button class="ai-btn" onclick="formatText('recordResult', 'telegram')">‚úàÔ∏è Telegram</button>
              <button class="ai-btn" onclick="formatAllText('recordResult')">üåê All Platforms</button>
            </div>
          </div>
        </div>

        <!-- WebSocket Live Feature -->
        <div class="feature-card">
          <h3>‚ö° Real-time Streaming</h3>
          <p>Connect to our WebSocket service for ultra-low latency real-time transcription.</p>
          <div style="margin-bottom: 20px;">
            <label style="display: block; margin-bottom: 10px;">
              Mode:
              <select id="streamMode" style="margin-left: 10px; padding: 5px;">
                <option value="offline">Offline (Free)</option>
                <option value="online">Online (Premium)</option>
              </select>
            </label>
          </div>
          
          <!-- Real-time Streaming Limits Warning -->
          <div id="realTimeStreamingLimitsWarning" class="usage-info" style="display: none; margin-bottom: 15px;">
            <strong>‚ö° Real-time Streaming Limits:</strong>
            <div id="realTimeStreamingLimitsText">Loading limits...</div>
          </div>
          <div style="text-align: center; margin-bottom: 20px;">
            <button class="btn btn-primary" id="connectBtn">Connect</button>
            <button class="btn btn-secondary" id="disconnectBtn" disabled>Disconnect</button>
          </div>
          <div style="text-align: center; margin-bottom: 20px;">
            <button class="btn btn-primary" id="startMicBtn" disabled>Start Mic</button>
            <button class="btn btn-secondary" id="stopMicBtn" disabled>Stop Mic</button>
            <button class="btn btn-secondary" id="endSessionBtn" disabled>End Session</button>
          </div>
          <div class="result-area" id="streamResult">
            <div style="margin-bottom: 20px;">
              <h4 style="color: #667eea; margin-bottom: 10px;">üìù Current (Latest)</h4>
              <div class="transcript-text" id="currentTranscript" style="background: #f0f8ff; padding: 15px; border-radius: 8px; border-left: 4px solid #667eea; min-height: 60px; font-style: italic; color: #666;">
                Current speech will appear here...
              </div>
            </div>
            <div>
              <h4 style="color: #27ae60; margin-bottom: 10px;">üìÑ Complete Transcript</h4>
              <div class="transcript-text" id="fullTranscript" style="background: #f0f9f4; padding: 15px; border-radius: 8px; border-left: 4px solid #27ae60; min-height: 120px; max-height: 300px; overflow-y: auto;">
                Complete transcript will appear here...
              </div>
              <!-- AI Features Warning -->
              <div id="streamAiLimitsWarning" class="usage-info" style="display: none; margin-bottom: 15px;">
                <strong>ü§ñ AI Features:</strong>
                <div id="streamAiLimitsText">Loading AI limits...</div>
              </div>
              
              <div class="ai-buttons" id="streamAiButtons" style="display: none; margin-top: 15px;">
                <button class="ai-btn" onclick="summarizeText('streamResult')">üìù Summarize</button>
                <button class="ai-btn" onclick="formatText('streamResult', 'facebook')">üìò Facebook</button>
                <button class="ai-btn" onclick="formatText('streamResult', 'whatsapp')">üí¨ WhatsApp</button>
                <button class="ai-btn" onclick="formatText('streamResult', 'x')">üê¶ X</button>
                <button class="ai-btn" onclick="formatText('streamResult', 'instagram')">üì∑ Instagram</button>
                <button class="ai-btn" onclick="formatText('streamResult', 'telegram')">‚úàÔ∏è Telegram</button>
                <button class="ai-btn" onclick="formatAllText('streamResult')">üåê All Platforms</button>
              </div>
            </div>
          </div>
        </div>

        <!-- Voice Translation Feature -->
        <div class="feature-card">
          <h3>üåç Voice Translation</h3>
          <p>Translate Hausa speech to English, French, or Arabic with real-time voice output. Complete translation pipeline in one click!</p>
          
          <!-- Translation Limits Warning -->
          <div id="translationLimitsWarning" class="usage-info" style="display: none; margin-bottom: 15px;">
            <strong>üåç Translation Limits:</strong>
            <div id="translationLimitsText">Loading limits...</div>
          </div>
          
          <!-- Language Selection -->
          <div style="margin-bottom: 20px;">
            <label style="display: block; margin-bottom: 10px; font-weight: 500;">
              Target Language:
            </label>
            <select id="translationLanguage" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 1rem;">
              <option value="en">üá∫üá∏ English</option>
              <option value="fr">üá´üá∑ French</option>
              <option value="ar">üá∏üá¶ Arabic</option>
            </select>
          </div>

          <!-- Voice Selection -->
          <div style="margin-bottom: 20px;">
            <label style="display: block; margin-bottom: 10px; font-weight: 500;">
              Voice Type:
            </label>
            <select id="translationVoice" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 1rem;">
              <option value="">Auto-select best voice</option>
            </select>
          </div>

          <!-- Translation Controls -->
          <div style="text-align: center; margin-bottom: 20px;">
            <button class="btn btn-primary" id="startTranslationBtn">üé§ Start Translation</button>
            <button class="btn btn-secondary" id="stopTranslationBtn" disabled>‚èπÔ∏è Stop Translation</button>
          </div>

          <!-- Translation Input -->
          <div style="margin-bottom: 20px;">
            <label style="display: block; margin-bottom: 10px; font-weight: 500;">
              Or enter Hausa text:
            </label>
            <textarea id="translationTextInput" placeholder="Type Hausa text here..." style="width: 100%; padding: 15px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 1rem; min-height: 80px; resize: vertical;"></textarea>
            <button class="btn btn-primary" id="translateTextBtn" style="margin-top: 10px;">üìù Translate Text</button>
          </div>

          <!-- Translation Results -->
          <div class="result-area" id="translationResult">
            <div class="transcript-text">Translation results will appear here...</div>
          </div>

          <!-- Audio Player -->
          <div id="translationAudioPlayer" style="display: none; margin-top: 15px;">
            <h4 style="color: #667eea; margin-bottom: 10px;">üéß Translated Audio:</h4>
            <audio id="translationAudio" controls style="width: 100%; margin-bottom: 10px;"></audio>
            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
              <button class="ai-btn" onclick="playTranslationAudio()">‚ñ∂Ô∏è Play</button>
              <button class="ai-btn" onclick="pauseTranslationAudio()">‚è∏Ô∏è Pause</button>
              <button class="ai-btn" onclick="downloadTranslationAudio()">üíæ Download</button>
            </div>
          </div>
        </div>

        <!-- Points & Premium Features -->
        <div class="feature-card">
          <h3>‚≠ê Points & Premium</h3>
          <p>Earn points by watching ads and unlock premium features. Upgrade your subscription for unlimited access.</p>
          <div style="margin-bottom: 15px;">
            <button class="btn btn-primary" id="watchAdBtn">Watch Ad (+10 Points)</button>
            <button class="btn btn-secondary" id="showPlansBtn">View Plans</button>
          </div>
          <div class="result-area" id="pointsResult">
            <div class="transcript-text">Points and subscription info will appear here...</div>
          </div>
        </div>
      </div>

      <!-- Debug Log -->
      <div class="feature-card">
        <h3>üîç Debug Log</h3>
        <div class="log" id="debugLog"></div>
      </div>
    </div>
  </div>

  <!-- AI Modals -->
  
  <!-- Summarize Modal -->
  <div class="modal" id="summarizeModal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 class="modal-title">üìù Text Summary</h3>
        <button class="close-btn" onclick="closeModal('summarizeModal')">&times;</button>
      </div>
      <div id="summarizeUsageInfo" class="usage-info" style="display: none;"></div>
      <div class="ai-result">
        <h4>Original Text:</h4>
        <div class="ai-result-text" id="summarizeOriginal"></div>
      </div>
      <div class="ai-result">
        <h4>Summary (Hausa):</h4>
        <div class="ai-result-text" id="summarizeResult"></div>
        <button class="copy-btn" onclick="copyToClipboard('summarizeResult')">üìã Copy Summary</button>
      </div>
    </div>
  </div>

  <!-- Format Modal -->
  <div class="modal" id="formatModal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 class="modal-title">üì± Social Media Formatting</h3>
        <button class="close-btn" onclick="closeModal('formatModal')">&times;</button>
      </div>
      <div id="formatUsageInfo" class="usage-info" style="display: none;"></div>
      <div class="ai-result">
        <h4>Original Text:</h4>
        <div class="ai-result-text" id="formatOriginal"></div>
      </div>
      <div class="ai-result">
        <h4>Formatted Text:</h4>
        <div class="ai-result-text" id="formatResult"></div>
        <button class="copy-btn" onclick="copyToClipboard('formatResult')">üìã Copy Formatted Text</button>
      </div>
    </div>
  </div>

  <!-- Format All Modal -->
  <div class="modal" id="formatAllModal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 class="modal-title">üåê All Platforms Formatting</h3>
        <button class="close-btn" onclick="closeModal('formatAllModal')">&times;</button>
      </div>
      <div id="formatAllUsageInfo" class="usage-info" style="display: none;"></div>
      <div class="ai-result">
        <h4>Original Text:</h4>
        <div class="ai-result-text" id="formatAllOriginal"></div>
      </div>
      <div class="platform-tabs">
        <button class="platform-tab active" onclick="showPlatform('facebook')">üìò Facebook</button>
        <button class="platform-tab" onclick="showPlatform('whatsapp')">üí¨ WhatsApp</button>
        <button class="platform-tab" onclick="showPlatform('x')">üê¶ X (Twitter)</button>
        <button class="platform-tab" onclick="showPlatform('instagram')">üì∑ Instagram</button>
        <button class="platform-tab" onclick="showPlatform('telegram')">‚úàÔ∏è Telegram</button>
      </div>
      <div id="facebook" class="platform-content active">
        <div class="ai-result">
          <h4>Facebook Format:</h4>
          <div class="ai-result-text" id="facebookResult"></div>
          <button class="copy-btn" onclick="copyToClipboard('facebookResult')">üìã Copy</button>
        </div>
      </div>
      <div id="whatsapp" class="platform-content">
        <div class="ai-result">
          <h4>WhatsApp Format:</h4>
          <div class="ai-result-text" id="whatsappResult"></div>
          <button class="copy-btn" onclick="copyToClipboard('whatsappResult')">üìã Copy</button>
        </div>
      </div>
      <div id="x" class="platform-content">
        <div class="ai-result">
          <h4>X (Twitter) Format:</h4>
          <div class="ai-result-text" id="xResult"></div>
          <button class="copy-btn" onclick="copyToClipboard('xResult')">üìã Copy</button>
        </div>
      </div>
      <div id="instagram" class="platform-content">
        <div class="ai-result">
          <h4>Instagram Format:</h4>
          <div class="ai-result-text" id="instagramResult"></div>
          <button class="copy-btn" onclick="copyToClipboard('instagramResult')">üìã Copy</button>
        </div>
      </div>
      <div id="telegram" class="platform-content">
        <div class="ai-result">
          <h4>Telegram Format:</h4>
          <div class="ai-result-text" id="telegramResult"></div>
          <button class="copy-btn" onclick="copyToClipboard('telegramResult')">üìã Copy</button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
  <script>
    // Global variables
    let currentUser = null;
    let authToken = null;
    let mediaRecorder = null;
    let recordedChunks = [];

    // Load saved authentication state
    function loadAuthState() {
      const savedUser = localStorage.getItem('currentUser');
      const savedToken = localStorage.getItem('authToken');
      
      if (savedUser && savedToken) {
        try {
          currentUser = JSON.parse(savedUser);
          authToken = savedToken;
          showUserInterface();
          log('Authentication state restored from localStorage');
        } catch (error) {
          log('Error loading saved auth state: ' + error.message);
          clearAuthState();
        }
      }
    }

    // Save authentication state
    function saveAuthState() {
      if (currentUser && authToken) {
        localStorage.setItem('currentUser', JSON.stringify(currentUser));
        localStorage.setItem('authToken', authToken);
        log('Authentication state saved to localStorage');
      }
    }

    // Clear authentication state
    function clearAuthState() {
      localStorage.removeItem('currentUser');
      localStorage.removeItem('authToken');
      currentUser = null;
      authToken = null;
    }

    // Utility functions
    function log(message) {
      const logEl = document.getElementById('debugLog');
      const timestamp = new Date().toISOString();
      logEl.innerHTML += `[${timestamp}] ${message}\n`;
      logEl.scrollTop = logEl.scrollHeight;
    }

    function showError(message, elementId) {
      const element = document.getElementById(elementId);
      element.innerHTML = `<div class="error">${message}</div>`;
    }

    function showSuccess(message, elementId) {
      const element = document.getElementById(elementId);
      element.innerHTML = `<div class="success">${message}</div>`;
    }

    function showLoading(message, elementId) {
      const element = document.getElementById(elementId);
      element.innerHTML = `<div class="loading">${message}</div>`;
    }

    function formatMinutes(minutes) {
      if (minutes === 0) return '0';
      if (minutes < 1) {
        // For values less than 1 minute, show seconds
        const seconds = Math.round(minutes * 60);
        return `${seconds}s`;
      }
      if (minutes < 60) {
        // For values less than 1 hour, show minutes with 1 decimal place
        return `${minutes.toFixed(1)}m`;
      }
      // For values 1 hour or more, show hours and minutes
      const hours = Math.floor(minutes / 60);
      const remainingMinutes = Math.round(minutes % 60);
      if (remainingMinutes === 0) {
        return `${hours}h`;
      }
      return `${hours}h ${remainingMinutes}m`;
    }

    // Authentication functions
    function showAuthForm(formType) {
      console.log('Switching to form:', formType);
      document.querySelectorAll('.auth-tab').forEach(tab => tab.classList.remove('active'));
      document.querySelectorAll('.auth-form').forEach(form => form.classList.remove('active'));
      
      if (formType === 'login') {
        document.getElementById('loginTab').classList.add('active');
        document.getElementById('loginForm').classList.add('active');
      } else {
        document.getElementById('registerTab').classList.add('active');
        document.getElementById('registerForm').classList.add('active');
      }
      console.log('Form switched successfully');
    }

    async function handleLogin(event) {
      try {
        event.preventDefault();
        console.log('Login form submitted');
        const email = document.getElementById('loginEmail').value;
        const password = document.getElementById('loginPassword').value;

        console.log('Email:', email, 'Password length:', password.length);

        if (!email || !password) {
          showError('Please fill in all fields', 'loginForm');
          return;
        }

        showLoading('Logging in...', 'loginForm');

        const response = await fetch('/api/auth/login', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ email, password })
        });

        const data = await response.json();

        if (data.success) {
          currentUser = data.user;
          authToken = data.token;
          saveAuthState();
          showUserInterface();
          log('Login successful');
        } else {
          showError(data.message || data.error || 'Login failed', 'loginForm');
        }
      } catch (error) {
        console.error('Error in handleLogin:', error);
        showError('Error: ' + error.message, 'loginForm');
        log('Login error: ' + error.message);
      }
    }

    async function handleRegister(event) {
      try {
        event.preventDefault();
        console.log('Register form submitted');
        const name = document.getElementById('registerName').value;
        const email = document.getElementById('registerEmail').value;
        const password = document.getElementById('registerPassword').value;

        console.log('Name:', name, 'Email:', email, 'Password length:', password.length);

        if (!name || !email || !password) {
          showError('Please fill in all fields', 'registerForm');
          return;
        }

        if (password.length < 8) {
          showError('Password must be at least 8 characters long', 'registerForm');
          return;
        }

        showLoading('Creating account...', 'registerForm');

        const response = await fetch('/api/auth/register', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name, email, password })
        });

        const data = await response.json();

        if (data.success) {
          currentUser = data.user;
          authToken = data.token;
          saveAuthState();
          showUserInterface();
          log('Registration successful');
        } else {
          showError(data.message || data.error || 'Registration failed', 'registerForm');
        }
      } catch (error) {
        console.error('Error in handleRegister:', error);
        showError('Error: ' + error.message, 'registerForm');
        log('Registration error: ' + error.message);
      }
    }

    function logout() {
      clearAuthState();
      document.getElementById('authSection').classList.remove('hidden');
      document.getElementById('userInfo').classList.remove('active');
      document.getElementById('mainContent').classList.remove('active');
      log('Logged out');
    }

    function showUserInterface() {
      document.getElementById('authSection').classList.add('hidden');
      document.getElementById('userInfo').classList.add('active');
      document.getElementById('mainContent').classList.add('active');
      
      updateUserInfo();
      loadUserStats();
    }

    function updateUserInfo() {
      document.getElementById('userName').textContent = currentUser.name;
      document.getElementById('userTier').textContent = currentUser.subscriptionTier.toUpperCase();
      document.getElementById('pointsDisplay').textContent = `${currentUser.pointsBalance} Points`;
    }

    async function loadUserStats() {
      try {
        const response = await fetch('/api/auth/usage', {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });

        const data = await response.json();
        if (data.success) {
          const usage = data.stats.usage;
          const points = data.stats.points;
          const tier = data.stats.tier;
          const limits = data.stats.limits;
          
          document.getElementById('userStats').innerHTML = `
            <div class="stat-item">
              <div class="stat-value">${formatMinutes(usage.dailyMinutes)}</div>
              <div class="stat-label">Daily Minutes</div>
            </div>
            <div class="stat-item">
              <div class="stat-value">${formatMinutes(usage.monthlyMinutes)}</div>
              <div class="stat-label">Monthly Minutes</div>
            </div>
            <div class="stat-item">
              <div class="stat-value">${formatMinutes(usage.totalMinutes)}</div>
              <div class="stat-label">Total Minutes</div>
            </div>
            <div class="stat-item">
              <div class="stat-value">${usage.transcriptsCount}</div>
              <div class="stat-label">Transcripts</div>
            </div>
            <div class="stat-item">
              <div class="stat-value">${points}</div>
              <div class="stat-label">Points</div>
            </div>
            <div class="stat-item">
              <div class="stat-value">${tier.toUpperCase()}</div>
              <div class="stat-label">Tier</div>
            </div>
          `;
          
          // Update file upload limits
          updateFileUploadLimits(usage, limits, tier);
          
          // Update live recording limits
          updateLiveRecordingLimits(usage, limits, tier);
          
          // Update real-time streaming limits
          updateRealTimeStreamingLimits(usage, limits, tier);
          
          // Update translation limits
          updateTranslationLimits(usage, limits, tier);
          
          // Update AI limits
          updateAILimits(usage, limits, tier);
          
          log('User stats loaded: ' + JSON.stringify(data.stats));
        }
      } catch (error) {
        log('Error loading user stats: ' + error.message);
      }
    }

    function updateFileUploadLimits(usage, limits, tier) {
      const dailyUploads = usage.dailyFileUploads || 0;
      const maxDailyUploads = limits.dailyFileUploads || 2;
      const maxFileDuration = limits.maxFileDuration || 3;
      
      // Show upload limits section
      document.getElementById('uploadLimits').style.display = 'block';
      
      // Update daily uploads display
      document.getElementById('dailyUploads').textContent = `${dailyUploads}/${maxDailyUploads}`;
      document.getElementById('maxFileDuration').textContent = `${maxFileDuration} minutes`;
      document.getElementById('subscriptionTier').textContent = tier.toUpperCase();
      
      // Calculate progress percentage
      const progressPercentage = maxDailyUploads > 0 ? (dailyUploads / maxDailyUploads) * 100 : 0;
      const progressBar = document.getElementById('uploadProgress');
      const limitText = document.getElementById('uploadLimitText');
      
      // Update progress bar
      progressBar.style.width = `${Math.min(progressPercentage, 100)}%`;
      
      // Update progress bar color based on usage
      progressBar.className = 'progress-fill';
      if (progressPercentage >= 80) {
        progressBar.classList.add('danger');
      } else if (progressPercentage >= 60) {
        progressBar.classList.add('warning');
      }
      
      // Update limit text
      const remaining = maxDailyUploads - dailyUploads;
      if (remaining <= 0) {
        limitText.textContent = 'No uploads remaining today';
        limitText.className = 'limit-text danger';
      } else if (remaining === 1) {
        limitText.textContent = '1 upload remaining today';
        limitText.className = 'limit-text warning';
      } else {
        limitText.textContent = `${remaining} uploads remaining today`;
        limitText.className = 'limit-text';
      }
      
      // Update upload limits warning in file upload section
      updateUploadLimitsWarning(dailyUploads, maxDailyUploads, maxFileDuration, tier);
    }

    function updateLiveRecordingLimits(usage, limits, tier) {
      const dailyLiveRecordingMinutes = usage.dailyLiveRecordingMinutes || 0;
      const maxDailyLiveRecordingMinutes = limits.dailyLiveRecordingMinutes || 5;
      
      // Show live recording limits section
      document.getElementById('liveRecordingLimits').style.display = 'block';
      
      // Update daily live recording minutes display with formatted time
      document.getElementById('dailyLiveRecordingMinutes').textContent = `${formatMinutes(dailyLiveRecordingMinutes)}/${formatMinutes(maxDailyLiveRecordingMinutes)}`;
      document.getElementById('liveRecordingSubscriptionTier').textContent = tier.toUpperCase();
      
      // Calculate progress percentage
      const progressPercentage = Math.min((dailyLiveRecordingMinutes / maxDailyLiveRecordingMinutes) * 100, 100);
      const progressBar = document.getElementById('liveRecordingProgress');
      const progressText = document.getElementById('liveRecordingLimitText');
      
      // Update progress bar
      progressBar.style.width = `${progressPercentage}%`;
      progressBar.className = 'progress-fill';
      
      // Add warning/danger classes based on usage
      if (progressPercentage >= 100) {
        progressBar.classList.add('danger');
        progressText.textContent = 'No live recording time remaining today';
      } else if (progressPercentage >= 80) {
        progressBar.classList.add('warning');
        const remaining = maxDailyLiveRecordingMinutes - dailyLiveRecordingMinutes;
        progressText.textContent = `${formatMinutes(remaining)} remaining today`;
      } else {
        const remaining = maxDailyLiveRecordingMinutes - dailyLiveRecordingMinutes;
        progressText.textContent = `${formatMinutes(remaining)} remaining today`;
      }
      
      // Update live recording limits warning in live recording section
      updateLiveRecordingLimitsWarning(dailyLiveRecordingMinutes, maxDailyLiveRecordingMinutes, tier);
    }

    function updateLiveRecordingLimitsWarning(dailyLiveRecordingMinutes, maxDailyLiveRecordingMinutes, tier) {
      const warningElement = document.getElementById('liveRecordingLimitsWarning');
      const textElement = document.getElementById('liveRecordingLimitsText');
      
      if (!warningElement || !textElement) return;
      
      const remaining = maxDailyLiveRecordingMinutes - dailyLiveRecordingMinutes;
      let warningClass = 'usage-info';
      let warningText = '';
      
      if (remaining <= 0) {
        warningClass += ' error';
        warningText = `‚ùå No live recording time remaining today (${formatMinutes(dailyLiveRecordingMinutes)}/${formatMinutes(maxDailyLiveRecordingMinutes)} used).`;
      } else if (remaining <= 1) {
        warningClass += ' warning';
        warningText = `‚ö†Ô∏è ${formatMinutes(remaining)} remaining today (${formatMinutes(dailyLiveRecordingMinutes)}/${formatMinutes(maxDailyLiveRecordingMinutes)} used).`;
      } else {
        warningText = `‚úÖ ${formatMinutes(remaining)} remaining today (${formatMinutes(dailyLiveRecordingMinutes)}/${formatMinutes(maxDailyLiveRecordingMinutes)} used).`;
      }
      
      warningElement.className = warningClass;
      textElement.textContent = warningText;
      warningElement.style.display = 'block';
    }

    function updateRealTimeStreamingLimits(usage, limits, tier) {
      const dailyRealTimeStreamingMinutes = usage.dailyRealTimeStreamingMinutes || 0;
      const maxDailyRealTimeStreamingMinutes = limits.dailyRealTimeStreamingMinutes || 3;
      
      // Show real-time streaming limits section
      document.getElementById('realTimeStreamingLimits').style.display = 'block';
      
      // Update daily real-time streaming minutes display with formatted time
      document.getElementById('dailyRealTimeStreamingMinutes').textContent = `${formatMinutes(dailyRealTimeStreamingMinutes)}/${formatMinutes(maxDailyRealTimeStreamingMinutes)}`;
      document.getElementById('realTimeStreamingSubscriptionTier').textContent = tier.toUpperCase();
      
      // Calculate progress percentage
      const progressPercentage = Math.min((dailyRealTimeStreamingMinutes / maxDailyRealTimeStreamingMinutes) * 100, 100);
      const progressBar = document.getElementById('realTimeStreamingProgress');
      const progressText = document.getElementById('realTimeStreamingLimitText');
      
      // Update progress bar
      progressBar.style.width = `${progressPercentage}%`;
      progressBar.className = 'progress-fill';
      
      // Add warning/danger classes based on usage
      if (progressPercentage >= 100) {
        progressBar.classList.add('danger');
        progressText.textContent = 'No real-time streaming time remaining today';
      } else if (progressPercentage >= 80) {
        progressBar.classList.add('warning');
        const remaining = maxDailyRealTimeStreamingMinutes - dailyRealTimeStreamingMinutes;
        progressText.textContent = `${formatMinutes(remaining)} remaining today`;
      } else {
        const remaining = maxDailyRealTimeStreamingMinutes - dailyRealTimeStreamingMinutes;
        progressText.textContent = `${formatMinutes(remaining)} remaining today`;
      }
      
      // Update real-time streaming limits warning in real-time streaming section
      updateRealTimeStreamingLimitsWarning(dailyRealTimeStreamingMinutes, maxDailyRealTimeStreamingMinutes, tier);
    }

    // Update translation limits display
    function updateTranslationLimits(usage, limits, tier) {
      const dailyTranslationMinutes = usage.dailyTranslationMinutes || 0;
      const maxDailyTranslationMinutes = limits.dailyTranslationMinutes || 0;
      
      // Show translation limits section
      document.getElementById('translationLimits').style.display = 'block';
      
      document.getElementById('dailyTranslationMinutes').textContent = 
        `${formatMinutes(dailyTranslationMinutes)}/${formatMinutes(maxDailyTranslationMinutes)}`;
      document.getElementById('translationSubscriptionTier').textContent = tier;
      
      // Update progress bar
      const progressElement = document.getElementById('translationProgress');
      const progressText = document.getElementById('translationLimitText');
      
      if (maxDailyTranslationMinutes > 0) {
        const percentage = (dailyTranslationMinutes / maxDailyTranslationMinutes) * 100;
        progressElement.style.width = `${Math.min(percentage, 100)}%`;
        
        if (percentage >= 90) {
          progressElement.className = 'progress-fill danger';
        } else if (percentage >= 70) {
          progressElement.className = 'progress-fill warning';
        } else {
          progressElement.className = 'progress-fill';
        }
        
        const remaining = maxDailyTranslationMinutes - dailyTranslationMinutes;
        progressText.textContent = `${formatMinutes(remaining)} remaining today`;
      } else {
        progressElement.style.width = '0%';
        progressText.textContent = 'No translation access';
      }
      
      // Update warning in translation section
      updateTranslationLimitsWarning(dailyTranslationMinutes, maxDailyTranslationMinutes, tier);
    }

    // Update AI limits display
    function updateAILimits(usage, limits, tier) {
      const dailyAIRequests = usage.dailyAIRequests || 0;
      const monthlyAIRequests = usage.monthlyAIRequests || 0;
      const maxDailyAIRequests = limits.dailyAIRequests || 5;
      const maxMonthlyAIRequests = limits.monthlyAIRequests || 150;
      const aiFeatures = limits.aiFeatures || ['basic_punctuation'];
      
      // Show AI limits section
      document.getElementById('aiLimits').style.display = 'block';
      
      document.getElementById('dailyAIRequests').textContent = 
        `${dailyAIRequests}/${maxDailyAIRequests === -1 ? '‚àû' : maxDailyAIRequests}`;
      document.getElementById('monthlyAIRequests').textContent = 
        `${monthlyAIRequests}/${maxMonthlyAIRequests === -1 ? '‚àû' : maxMonthlyAIRequests}`;
      document.getElementById('availableAIFeatures').textContent = aiFeatures.join(', ');
      document.getElementById('aiSubscriptionTier').textContent = tier;
      
      // Update progress bar
      const progressElement = document.getElementById('aiProgress');
      const progressText = document.getElementById('aiLimitText');
      
      if (maxDailyAIRequests === 0) {
        // No AI access
        progressElement.style.width = '0%';
        progressText.textContent = 'No AI access';
      } else if (maxDailyAIRequests === -1) {
        // Unlimited AI requests
        progressElement.style.width = '0%';
        progressText.textContent = 'Unlimited requests';
      } else {
        // Limited AI requests
        const percentage = (dailyAIRequests / maxDailyAIRequests) * 100;
        progressElement.style.width = `${Math.min(percentage, 100)}%`;
        
        if (percentage >= 90) {
          progressElement.className = 'progress-fill danger';
        } else if (percentage >= 70) {
          progressElement.className = 'progress-fill warning';
        } else {
          progressElement.className = 'progress-fill';
        }
        
        const remaining = maxDailyAIRequests - dailyAIRequests;
        progressText.textContent = `${remaining} requests remaining today`;
      }
      
      // Update warnings in all AI sections
      updateAILimitsWarning('uploadAiLimitsWarning', 'uploadAiLimitsText', dailyAIRequests, maxDailyAIRequests, tier, aiFeatures);
      updateAILimitsWarning('recordAiLimitsWarning', 'recordAiLimitsText', dailyAIRequests, maxDailyAIRequests, tier, aiFeatures);
      
      // Only show AI warning for streaming if there's actual content
      const fullTranscriptElement = document.getElementById('fullTranscript');
      const hasTranscriptContent = fullTranscriptElement && fullTranscriptElement.textContent.trim().length > 10;
      if (hasTranscriptContent) {
        updateAILimitsWarning('streamAiLimitsWarning', 'streamAiLimitsText', dailyAIRequests, maxDailyAIRequests, tier, aiFeatures);
      } else {
        const warningElement = document.getElementById('streamAiLimitsWarning');
        if (warningElement) {
          warningElement.style.display = 'none';
        }
      }
      
      // Update AI button availability based on features and limits
      const remaining = maxDailyAIRequests === -1 ? 999999 : (maxDailyAIRequests - dailyAIRequests);
      updateAIButtonAvailability(aiFeatures, remaining, maxDailyAIRequests);
    }

    function updateRealTimeStreamingLimitsWarning(dailyRealTimeStreamingMinutes, maxDailyRealTimeStreamingMinutes, tier) {
      const warningElement = document.getElementById('realTimeStreamingLimitsWarning');
      const textElement = document.getElementById('realTimeStreamingLimitsText');
      
      if (!warningElement || !textElement) return;
      
      const remaining = maxDailyRealTimeStreamingMinutes - dailyRealTimeStreamingMinutes;
      let warningClass = 'usage-info';
      let warningText = '';
      
      if (remaining <= 0) {
        warningClass += ' error';
        warningText = `‚ùå No real-time streaming time remaining today (${formatMinutes(dailyRealTimeStreamingMinutes)}/${formatMinutes(maxDailyRealTimeStreamingMinutes)} used).`;
      } else if (remaining <= 1) {
        warningClass += ' warning';
        warningText = `‚ö†Ô∏è ${formatMinutes(remaining)} remaining today (${formatMinutes(dailyRealTimeStreamingMinutes)}/${formatMinutes(maxDailyRealTimeStreamingMinutes)} used).`;
      } else {
        warningText = `‚úÖ ${formatMinutes(remaining)} remaining today (${formatMinutes(dailyRealTimeStreamingMinutes)}/${formatMinutes(maxDailyRealTimeStreamingMinutes)} used).`;
      }
      
      warningElement.className = warningClass;
      textElement.textContent = warningText;
      warningElement.style.display = 'block';
    }

    function updateTranslationLimitsWarning(dailyTranslationMinutes, maxDailyTranslationMinutes, tier) {
      const warningElement = document.getElementById('translationLimitsWarning');
      const textElement = document.getElementById('translationLimitsText');
      
      if (!warningElement || !textElement) return;

      if (maxDailyTranslationMinutes === 0) {
        textElement.textContent = `Translation not available for ${tier} tier. Upgrade to Gold or Premium for translation features.`;
        warningElement.className = 'usage-info error';
        warningElement.style.display = 'block';
        return;
      }

      const remaining = maxDailyTranslationMinutes - dailyTranslationMinutes;
      let warningText = '';
      let warningClass = 'usage-info';

      if (remaining <= 0) {
        warningText = `‚ùå No translation time remaining today (${formatMinutes(dailyTranslationMinutes)}/${formatMinutes(maxDailyTranslationMinutes)} used).`;
        warningClass = 'usage-info error';
      } else if (remaining <= maxDailyTranslationMinutes * 0.1) {
        warningText = `‚ö†Ô∏è Translation time almost used up: ${formatMinutes(remaining)} remaining today.`;
        warningClass = 'usage-info warning';
      } else {
        warningText = `‚úÖ ${formatMinutes(remaining)} translation time remaining today.`;
        warningClass = 'usage-info success';
      }

      warningElement.className = warningClass;
      textElement.textContent = warningText;
      warningElement.style.display = 'block';
    }

    function updateAILimitsWarning(warningElementId, textElementId, dailyAIRequests, maxDailyAIRequests, tier, aiFeatures) {
      const warningElement = document.getElementById(warningElementId);
      const textElement = document.getElementById(textElementId);
      
      if (!warningElement || !textElement) return;

      let warningText = '';
      let warningClass = 'usage-info';

      if (maxDailyAIRequests === 0) {
        warningText = `AI features not available for ${tier} tier. Upgrade to Basic or higher for AI features.`;
        warningClass = 'usage-info error';
      } else if (maxDailyAIRequests === -1) {
        // Unlimited AI requests
        warningText = `‚úÖ Unlimited AI requests available. Available features: ${aiFeatures.join(', ')}`;
        warningClass = 'usage-info success';
      } else {
        // Limited AI requests
        const remaining = maxDailyAIRequests - dailyAIRequests;
        if (remaining <= 0) {
          warningText = `‚ùå No AI requests remaining today (${dailyAIRequests}/${maxDailyAIRequests} used). Available features: ${aiFeatures.join(', ')}`;
          warningClass = 'usage-info error';
        } else if (remaining <= 2) {
          warningText = `‚ö†Ô∏è AI requests almost used up: ${remaining} remaining today. Available features: ${aiFeatures.join(', ')}`;
          warningClass = 'usage-info warning';
        } else {
          warningText = `‚úÖ ${remaining} AI requests remaining today. Available features: ${aiFeatures.join(', ')}`;
          warningClass = 'usage-info success';
        }
      }

      warningElement.className = warningClass;
      textElement.textContent = warningText;
      warningElement.style.display = 'block';
    }

    function updateAIButtonAvailability(aiFeatures, remainingRequests, maxDailyAIRequests) {
      const aiButtonSections = ['uploadAiButtons', 'recordAiButtons', 'streamAiButtons'];
      
      aiButtonSections.forEach(sectionId => {
        const section = document.getElementById(sectionId);
        if (!section) return;
        
        const buttons = section.querySelectorAll('.ai-btn');
        buttons.forEach(button => {
          // Disable buttons only if no AI access (maxDailyAIRequests === 0) or if limited and no requests remaining
          const isDisabled = maxDailyAIRequests === 0 || (maxDailyAIRequests > 0 && remainingRequests <= 0);
          button.disabled = isDisabled;
          
          if (isDisabled) {
            button.style.opacity = '0.5';
            button.style.cursor = 'not-allowed';
          } else {
            button.style.opacity = '1';
            button.style.cursor = 'pointer';
          }
        });
      });
    }

    function updateUploadLimitsWarning(dailyUploads, maxDailyUploads, maxFileDuration, tier) {
      const warningElement = document.getElementById('uploadLimitsWarning');
      const textElement = document.getElementById('uploadLimitsText');
      
      if (!warningElement || !textElement) return;
      
      const remaining = maxDailyUploads - dailyUploads;
      let warningClass = 'usage-info';
      let warningText = '';
      
      if (remaining <= 0) {
        warningClass += ' error';
        warningText = `‚ùå No uploads remaining today (${dailyUploads}/${maxDailyUploads} used). Max file duration: ${maxFileDuration} minutes.`;
      } else if (remaining === 1) {
        warningClass += ' warning';
        warningText = `‚ö†Ô∏è 1 upload remaining today (${dailyUploads}/${maxDailyUploads} used). Max file duration: ${maxFileDuration} minutes.`;
      } else {
        warningText = `‚úÖ ${remaining} uploads remaining today (${dailyUploads}/${maxDailyUploads} used). Max file duration: ${maxFileDuration} minutes.`;
      }
      
      warningElement.className = warningClass;
      textElement.textContent = warningText;
      warningElement.style.display = 'block';
    }

    // File upload functions
    function setupFileUpload() {
      const uploadArea = document.getElementById('uploadArea');
      const fileInput = document.getElementById('fileInput');
      const uploadBtn = document.getElementById('uploadBtn');

      uploadBtn.addEventListener('click', () => {
        fileInput.click();
      });

      uploadArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        uploadArea.classList.add('dragover');
      });

      uploadArea.addEventListener('dragleave', () => {
        uploadArea.classList.remove('dragover');
      });

      uploadArea.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadArea.classList.remove('dragover');
        const files = e.dataTransfer.files;
        if (files.length > 0) {
          fileInput.files = files;
          handleFileUpload(files[0]);
        }
      });

      fileInput.addEventListener('change', (e) => {
        if (e.target.files.length > 0) {
          handleFileUpload(e.target.files[0]);
        }
      });
    }

    async function handleFileUpload(file) {
      // Check file duration before uploading
      const duration = await getAudioDuration(file);
      const durationMinutes = duration / 60;
      
      // Get user's file duration limit
      const maxDuration = getMaxFileDuration();
      
      if (maxDuration > 0 && durationMinutes > maxDuration) {
        showError(`File too long! Maximum ${maxDuration} minutes allowed. Your file is ${formatMinutes(durationMinutes)}.`, 'uploadResult');
        log(`File duration exceeded: ${formatMinutes(durationMinutes)} > ${maxDuration} min limit`);
        return;
      }
      
      // Get selected languages
      const sourceLanguage = document.getElementById('sourceLanguage').value;
      const targetLanguage = document.getElementById('targetLanguage').value;
      
      showLoading('Transcribing audio...', 'uploadResult');
      log('Uploading file: ' + file.name + ` (${formatMinutes(durationMinutes)}) - Source: ${sourceLanguage}, Target: ${targetLanguage}`);

      const formData = new FormData();
      formData.append('audio', file);
      formData.append('languageCode', sourceLanguage);
      formData.append('sampleRateHertz', '16000');
      formData.append('targetLanguage', targetLanguage);

      try {
        const response = await fetch('/api/stt/transcribe', {
          method: 'POST',
          headers: authToken ? { 'Authorization': `Bearer ${authToken}` } : {},
          body: formData
        });

        const data = await response.json();

        if (response.ok) {
          const durationMinutes = data.duration / 60;
          
          // Display results based on whether translation was performed
          let resultHTML = '';
          
          if (data.transcript) {
            resultHTML += `
              <div class="ai-result">
                <h4>üìù Transcription (${getLanguageName(sourceLanguage)}):</h4>
                <div class="ai-result-text">${data.transcript}</div>
              </div>
            `;
          }
          
          if (data.translation && sourceLanguage !== targetLanguage) {
            resultHTML += `
              <div class="ai-result">
                <h4>üåç Translation (${getLanguageName(targetLanguage)}):</h4>
                <div class="ai-result-text">${data.translation}</div>
              </div>
            `;
          }
          
          resultHTML += `
            <div class="success">Processing completed successfully! Duration: ${formatMinutes(durationMinutes)}</div>
          `;
          
          document.getElementById('uploadResult').innerHTML = resultHTML;
          showAiButtons('uploadResult');
          log('Transcription successful');
          
          // Refresh user stats to update upload limits
          if (authToken) {
            loadUserStats();
          }
        } else {
          if (data.code === 'FILE_UPLOAD_LIMIT_EXCEEDED') {
            showError(`Upload limit exceeded: ${data.details.reason}`, 'uploadResult');
            log('Upload limit exceeded: ' + data.details.reason);
          } else {
            showError(data.message || 'Transcription failed', 'uploadResult');
            log('Transcription error: ' + (data.message || 'Unknown error'));
          }
        }
      } catch (error) {
        showError('Network error: ' + error.message, 'uploadResult');
        log('Upload error: ' + error.message);
      }
    }

    // Helper function to get audio duration
    function getAudioDuration(file) {
      return new Promise((resolve) => {
        const audio = new Audio();
        const url = URL.createObjectURL(file);
        
        audio.addEventListener('loadedmetadata', () => {
          URL.revokeObjectURL(url);
          resolve(audio.duration);
        });
        
        audio.addEventListener('error', () => {
          URL.revokeObjectURL(url);
          // Fallback: estimate duration based on file size
          // Assume 16kHz, 16-bit mono = 32KB per second
          const estimatedDuration = file.size / (16000 * 2);
          resolve(estimatedDuration);
        });
        
        audio.src = url;
      });
    }

    // Helper function to get max file duration from current user
    function getMaxFileDuration() {
      if (!currentUser) return 3; // Default for anonymous users
      
      // This would be set when user stats are loaded
      const maxDurationElement = document.getElementById('maxFileDuration');
      if (maxDurationElement) {
        const text = maxDurationElement.textContent;
        const match = text.match(/(\d+)\s*minutes?/);
        return match ? parseInt(match[1]) : 3;
      }
      
      return 3; // Default fallback
    }

    // UsageService class for frontend usage checks
    class UsageService {
      async checkLiveRecordingUsage(userId, requestedMinutes) {
        try {
          const response = await fetch('/api/usage/check-live-recording', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({
              userId,
              requestedMinutes
            })
          });
          
          const data = await response.json();
          return data;
        } catch (error) {
          console.error('Error checking live recording usage:', error);
          return {
            allowed: false,
            remainingMinutes: 0,
            tier: 'free',
            reason: 'Error checking live recording limits'
          };
        }
      }

      async recordLiveRecordingUsage(userId, minutes) {
        try {
          const response = await fetch('/api/usage/record-live-recording', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({
              userId,
              minutes
            })
          });
          
          const data = await response.json();
          return data;
        } catch (error) {
          console.error('Error recording live recording usage:', error);
          return { success: false };
        }
      }

      async checkRealTimeStreamingUsage(userId, requestedMinutes) {
        try {
          const response = await fetch('/api/usage/check-realtime-streaming', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({
              userId,
              requestedMinutes
            })
          });
          
          const data = await response.json();
          return data;
        } catch (error) {
          console.error('Error checking real-time streaming usage:', error);
          return {
            allowed: false,
            remainingMinutes: 0,
            tier: 'free',
            reason: 'Error checking real-time streaming limits'
          };
        }
      }

      async recordRealTimeStreamingUsage(userId, minutes) {
        try {
          const response = await fetch('/api/usage/record-realtime-streaming', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({
              userId,
              minutes
            })
          });
          
          const data = await response.json();
          return data;
        } catch (error) {
          console.error('Error recording real-time streaming usage:', error);
          return { success: false };
        }
      }
    }

    // Recording functions
    async function startRecording() {
      try {
        // Note: Live recording limits are validated when the recording is uploaded
        // with its actual duration, not during the pre-check

        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        recordedChunks = [];
        
        const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') 
          ? 'audio/webm;codecs=opus' 
          : 'audio/webm';
        
        mediaRecorder = new MediaRecorder(stream, { mimeType });
        mediaRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) {
            recordedChunks.push(e.data);
          }
        };
        
        mediaRecorder.start();
        document.getElementById('recordBtn').disabled = true;
        document.getElementById('stopBtn').disabled = false;
        showLoading('Recording... Click stop when done.', 'recordResult');
        log('Recording started');
      } catch (error) {
        showError('Microphone access denied: ' + error.message, 'recordResult');
        log('Recording error: ' + error.message);
      }
    }

    async function stopRecording() {
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
        document.getElementById('recordBtn').disabled = false;
        document.getElementById('stopBtn').disabled = true;
        
        mediaRecorder.onstop = async () => {
          const blob = new Blob(recordedChunks, { type: 'audio/webm' });
          const audio = document.getElementById('playback');
          audio.src = URL.createObjectURL(blob);
          
          showLoading('Transcribing recording...', 'recordResult');
          await handleRecordedAudio(blob);
        };
      }
    }

    async function handleRecordedAudio(blob) {
      log('Transcribing recorded audio...');

      // Get selected languages from Live Recording form
      const sourceLanguage = document.getElementById('recordSourceLanguage').value;
      const targetLanguage = document.getElementById('recordTargetLanguage').value;
      
      log(`Live recording languages - Source: ${sourceLanguage}, Target: ${targetLanguage}`);

      const formData = new FormData();
      formData.append('audio', blob);
      formData.append('languageCode', sourceLanguage);
      formData.append('sampleRateHertz', '16000');
      formData.append('source', 'live-recording'); // Mark as live recording
      formData.append('targetLanguage', targetLanguage);

      try {
        const response = await fetch('/api/stt/transcribe', {
          method: 'POST',
          headers: authToken ? { 'Authorization': `Bearer ${authToken}` } : {},
          body: formData
        });

        const data = await response.json();

        if (response.ok) {
          const durationMinutes = data.duration / 60;
          
          // Display results based on whether translation was performed
          let resultHTML = '';
          
          if (data.transcript) {
            resultHTML += `
              <div class="ai-result">
                <h4>üìù Transcription (${getLanguageName(sourceLanguage)}):</h4>
                <div class="ai-result-text">${data.transcript}</div>
              </div>
            `;
          }
          
          if (data.translation && sourceLanguage !== targetLanguage) {
            resultHTML += `
              <div class="ai-result">
                <h4>üåç Translation (${getLanguageName(targetLanguage)}):</h4>
                <div class="ai-result-text">${data.translation}</div>
              </div>
            `;
          }
          
          resultHTML += `
            <div class="success">Recording processed successfully! Duration: ${formatMinutes(durationMinutes)}</div>
          `;
          
          document.getElementById('recordResult').innerHTML = resultHTML;
          showAiButtons('recordResult');
          log('Recording transcription successful');
          
          // Refresh user stats to update live recording limits
          if (authToken) {
            loadUserStats();
          }
        } else {
          if (data.code === 'LIVE_RECORDING_LIMIT_EXCEEDED') {
            showError(`Live recording limit exceeded: ${data.details.reason}`, 'recordResult');
            log(`Live recording limit exceeded: ${data.details.reason}`);
          } else {
            showError(data.message || 'Transcription failed', 'recordResult');
            log('Recording transcription error: ' + (data.message || 'Unknown error'));
          }
        }
      } catch (error) {
        showError('Network error: ' + error.message, 'recordResult');
        log('Recording upload error: ' + error.message);
      }
    }

    // WebSocket streaming variables
    let liveSocket = null;
    let liveSessionId = null;
    let recStream = null;
    let liveCtx = null;
    let liveSource = null;
    let liveProcessor = null;
    let canSend = false;
    let fullTranscript = ''; // Stores complete transcript
    let currentPartial = ''; // Stores current partial text

    // Audio processing helpers
    function blobToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onerror = reject;
        reader.onloadend = () => {
          const dataUrl = reader.result;
          const base64 = String(dataUrl).split(',')[1];
          resolve(base64);
        };
        reader.readAsDataURL(blob);
      });
    }

    function encodePCM16(float32) {
      const buffer = new ArrayBuffer(float32.length * 2);
      const view = new DataView(buffer);
      for (let i = 0; i < float32.length; i++) {
        let s = Math.max(-1, Math.min(1, float32[i]));
        view.setInt16(i * 2, s < 0 ? s * 0x8000 : s * 0x7fff, true);
      }
      return new Uint8Array(buffer);
    }

    function downsampleBuffer(float32, inRate, outRate) {
      if (outRate === inRate) return float32;
      const ratio = inRate / outRate;
      const newLen = Math.floor(float32.length / ratio);
      const result = new Float32Array(newLen);
      let offsetResult = 0;
      let offsetBuffer = 0;
      while (offsetResult < result.length) {
        const nextOffsetBuffer = Math.round((offsetResult + 1) * ratio);
        let sum = 0;
        let count = 0;
        for (let i = offsetBuffer; i < nextOffsetBuffer && i < float32.length; i++) {
          sum += float32[i];
          count++;
        }
        result[offsetResult] = sum / count;
        offsetResult++;
        offsetBuffer = nextOffsetBuffer;
      }
      return result;
    }

    function uint8ToBase64(u8) {
      let binary = '';
      for (let i = 0; i < u8.byteLength; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
    }

    // WebSocket functions
    async function connectWebSocket() {
      const mode = document.getElementById('streamMode').value;
      const isPremium = currentUser ? currentUser.isPremium : false;
      
      // Check real-time streaming limits for authenticated users
      if (authToken && currentUser) {
        try {
          const usageService = new UsageService();
          const streamingCheck = await usageService.checkRealTimeStreamingUsage(
            currentUser.id,
            0.1 // Request 6 seconds minimum (will be tracked with actual duration)
          );

          if (!streamingCheck.allowed) {
            showError(`Real-time streaming limit exceeded: ${streamingCheck.reason}`, 'streamResult');
            log(`Real-time streaming limit exceeded: ${streamingCheck.reason}`);
            return;
          }
        } catch (error) {
          showError('Error checking real-time streaming limits: ' + error.message, 'streamResult');
          log('Error checking real-time streaming limits: ' + error.message);
          return;
        }
      }
      
      // Reset transcripts
      fullTranscript = '';
      currentPartial = '';
      document.getElementById('fullTranscript').textContent = 'Complete transcript will appear here...';
      document.getElementById('currentTranscript').textContent = 'Current speech will appear here...';
      
      // Hide AI warning initially
      const warningElement = document.getElementById('streamAiLimitsWarning');
      if (warningElement) {
        warningElement.style.display = 'none';
      }
      
      // Pass premium and user ID via query string for server gating and user tracking
      const userIdParam = currentUser?.id ? `&userId=${currentUser.id}` : '';
      liveSocket = io(`/transcription?premium=${isPremium}${userIdParam}`);

      liveSocket.on('connect', () => {
        log('[live] connected');
        log('[live] currentUser:', currentUser);
        log('[live] userId being sent:', currentUser?.id);
        liveSocket.emit('join_session', { mode, userId: currentUser?.id });
      });

      liveSocket.on('session_status', (msg) => {
        log('[live] session_status ' + JSON.stringify(msg));
        liveSessionId = msg.sessionId;
        
        if (msg.status === 'completed') {
          // Session completed - refresh user stats to update limits
          if (authToken) {
            loadUserStats();
          }
        } else if (msg.status === 'limit_exceeded') {
          // Handle limit exceeded - stop recording and show message
          log('[live] Real-time streaming limit exceeded - stopping session');
          endSession();
          showError('Daily real-time streaming limit reached. Session ended.', 'liveResult');
          // Refresh user stats to show updated limits
          if (authToken) {
            loadUserStats();
          }
        } else if (msg.status === 'active') {
          document.getElementById('connectBtn').disabled = true;
          document.getElementById('disconnectBtn').disabled = false;
          document.getElementById('startMicBtn').disabled = false;
          document.getElementById('endSessionBtn').disabled = false;
        }
      });

      liveSocket.on('transcript_update', (msg) => {
        if (msg.isFinal) {
          // Final text - add to complete transcript
          fullTranscript += (fullTranscript ? ' ' : '') + msg.text;
          currentPartial = ''; // Clear current partial
          
          // Update displays
          document.getElementById('fullTranscript').textContent = fullTranscript;
          document.getElementById('currentTranscript').textContent = 'Speaking...';
          
          // Show AI buttons when we have a complete transcript
          if (fullTranscript.trim().length > 10) {
            showAiButtons('streamResult');
            // Show AI limits warning only when there's content
            updateAILimitsWarning('streamAiLimitsWarning', 'streamAiLimitsText', 
              currentUser ? currentUser.usageStats?.dailyAIRequests || 0 : 0,
              currentUser ? currentUser.subscriptionTier === 'premium' ? -1 : 5 : 5,
              currentUser ? currentUser.subscriptionTier : 'free',
              currentUser ? ['basic_punctuation', 'auto_capitalization', 'unlimited_summary', 'translation', 'speaker_diarization', 'keywords_extraction', 'sentiment_analysis', 'batch_processing', 'custom_vocabulary'] : ['basic_punctuation']
            );
          } else {
            // Hide AI warning when no content
            const warningElement = document.getElementById('streamAiLimitsWarning');
            if (warningElement) {
              warningElement.style.display = 'none';
            }
          }
        } else {
          // Partial text - show in current only
          currentPartial = msg.text;
          document.getElementById('currentTranscript').textContent = currentPartial || 'Listening...';
        }
        
        log('[live] transcript_update: ' + msg.text + (msg.isFinal ? ' [FINAL]' : ' [PARTIAL]'));
      });

      liveSocket.on('ready', () => { 
        canSend = true; 
        log('[live] ready to send audio');
      });

      liveSocket.on('error', (err) => {
        if (err.code === 'REALTIME_STREAMING_LIMIT_EXCEEDED') {
          showError(`Real-time streaming limit exceeded: ${err.message}`, 'streamResult');
          log(`Real-time streaming limit exceeded: ${err.message}`);
        } else {
          showError('WebSocket error: ' + JSON.stringify(err), 'streamResult');
          log('[live] error ' + JSON.stringify(err));
        }
      });

      liveSocket.on('disconnect', () => {
        log('[live] disconnected');
        document.getElementById('connectBtn').disabled = false;
        document.getElementById('disconnectBtn').disabled = true;
        document.getElementById('startMicBtn').disabled = true;
        document.getElementById('stopMicBtn').disabled = true;
        document.getElementById('endSessionBtn').disabled = true;
        
        // Refresh user stats to update limits after disconnect
        if (authToken) {
          loadUserStats();
        }
      });

      document.getElementById('connectBtn').disabled = true;
    }

    function disconnectWebSocket() {
      if (liveSocket) {
        liveSocket.disconnect();
        liveSocket = null;
        liveSessionId = null;
      }
      
      // Reset transcripts
      fullTranscript = '';
      currentPartial = '';
      document.getElementById('fullTranscript').textContent = 'Complete transcript will appear here...';
      document.getElementById('currentTranscript').textContent = 'Current speech will appear here...';
      
      // Hide AI warning
      const warningElement = document.getElementById('streamAiLimitsWarning');
      if (warningElement) {
        warningElement.style.display = 'none';
      }
    }

    async function startMicStream() {
      try {
        recStream = await navigator.mediaDevices.getUserMedia({
          audio: { 
            channelCount: 1, 
            echoCancellation: true, 
            noiseSuppression: true, 
            autoGainControl: true 
          },
        });
        
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        // Request 16k if possible
        liveCtx = new AudioCtx({ sampleRate: 16000 });
        liveSource = liveCtx.createMediaStreamSource(recStream);
        const bufferSize = 1024; // ~64ms at 16k, reduces backpressure
        liveProcessor = liveCtx.createScriptProcessor(bufferSize, 1, 1);
        
        liveProcessor.onaudioprocess = (e) => {
          if (!liveSessionId) return;
          const input = e.inputBuffer.getChannelData(0);
          const desiredRate = 16000;
          const inRate = liveCtx.sampleRate || desiredRate;
          const ds = downsampleBuffer(input, inRate, desiredRate);
          
          if (canSend) {
            canSend = false;
            const pcm = encodePCM16(ds);
            const b64 = uint8ToBase64(pcm);
            liveSocket.emit('audio_chunk', { sessionId: liveSessionId, chunk: b64 });
          }
        };
        
        liveSource.connect(liveProcessor);
        liveProcessor.connect(liveCtx.destination);
        
        document.getElementById('startMicBtn').disabled = true;
        document.getElementById('stopMicBtn').disabled = false;
        log('[live] microphone started');
      } catch (e) {
        showError('Microphone error: ' + e.message, 'streamResult');
        log('[live] mic error ' + e.message);
      }
    }

    async function stopMicStream() {
      try {
        document.getElementById('stopMicBtn').disabled = true;
        if (liveProcessor) liveProcessor.disconnect();
        if (liveSource) liveSource.disconnect();
        if (liveCtx) await liveCtx.close();
        if (recStream) recStream.getTracks().forEach(t => t.stop());
        document.getElementById('startMicBtn').disabled = false;
        log('[live] microphone stopped');
      } catch (e) {
        log('[live] stop mic error: ' + e.message);
      }
    }

    function endSession() {
      if (!liveSocket || !liveSessionId) return;
      liveSocket.emit('end_session', { sessionId: liveSessionId });
      if (liveProcessor) liveProcessor.disconnect();
      if (liveSource) liveSource.disconnect();
      if (liveCtx && liveCtx.state !== 'closed') {
        liveCtx.close();
      }
      if (recStream) recStream.getTracks().forEach(t => t.stop());
      log('[live] session ended');
    }

    // Points and premium functions
    async function watchAd() {
      if (!authToken) {
        showError('Please login to watch ads and earn points', 'pointsResult');
        return;
      }

      showLoading('Watching ad...', 'pointsResult');
      
      try {
        // Generate a random ad ID for demo purposes
        const adId = 'ad_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        
        const response = await fetch('/api/points/watch-ad', {
          method: 'POST',
          headers: { 
            'Authorization': `Bearer ${authToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ adId })
        });

        const data = await response.json();

        if (data.success) {
          currentUser.pointsBalance = data.newBalance;
          updateUserInfo();
          showSuccess(`Ad watched! Earned ${data.pointsEarned} points. New balance: ${data.newBalance}`, 'pointsResult');
          log('Ad watched successfully');
        } else {
          showError(data.error || 'Failed to watch ad', 'pointsResult');
        }
      } catch (error) {
        showError('Network error: ' + error.message, 'pointsResult');
        log('Watch ad error: ' + error.message);
      }
    }

    async function showSubscriptionTiers() {
      try {
        const response = await fetch('/api/auth/subscription/tiers');
        const data = await response.json();

        if (data.success) {
          const tiers = data.tiers;
          let tiersHtml = '<h4>Available Plans:</h4>';
          
          Object.values(tiers).forEach(tier => {
            tiersHtml += `
              <div style="margin: 10px 0; padding: 15px; border: 1px solid #e0e0e0; border-radius: 8px;">
                <strong>${tier.name}</strong> - $${(tier.price / 100).toFixed(2)}/${tier.billingCycle}
                <br><small>${tier.description}</small>
                <br><small>Daily: ${tier.features.dailyMinutes === -1 ? 'Unlimited' : tier.features.dailyMinutes} min | 
                Monthly: ${tier.features.monthlyMinutes === -1 ? 'Unlimited' : tier.features.monthlyMinutes} min</small>
              </div>
            `;
          });

          document.getElementById('pointsResult').innerHTML = tiersHtml;
        }
      } catch (error) {
        showError('Failed to load subscription tiers: ' + error.message, 'pointsResult');
        log('Subscription tiers error: ' + error.message);
      }
    }

    // AI Functions
    function getTranscriptText(resultAreaId) {
      if (resultAreaId === 'streamResult') {
        // For streaming, get the full transcript
        return document.getElementById('fullTranscript').textContent.trim();
      } else {
        // For upload/record, get the transcript from the result area
        const resultArea = document.getElementById(resultAreaId);
        const transcriptElement = resultArea.querySelector('.transcript-text');
        return transcriptElement ? transcriptElement.textContent.trim() : '';
      }
    }

    function showAiButtons(resultAreaId) {
      const aiButtons = document.getElementById(resultAreaId.replace('Result', 'AiButtons'));
      if (aiButtons) {
        aiButtons.style.display = 'flex';
      }
    }

    function hideAiButtons(resultAreaId) {
      const aiButtons = document.getElementById(resultAreaId.replace('Result', 'AiButtons'));
      if (aiButtons) {
        aiButtons.style.display = 'none';
      }
    }

    function setButtonLoading(button, loading) {
      if (loading) {
        button.disabled = true;
        button.classList.add('loading');
        button.innerHTML = '‚è≥ Processing...';
      } else {
        button.disabled = false;
        button.classList.remove('loading');
        // Restore original text based on button content
        const originalText = button.getAttribute('data-original') || button.textContent;
        button.innerHTML = originalText;
      }
    }

    async function summarizeText(resultAreaId) {
      const text = getTranscriptText(resultAreaId);
      if (!text || text.length < 10) {
        showError('Please transcribe some audio first', resultAreaId);
        return;
      }

      const button = event.target;
      setButtonLoading(button, true);

      try {
        const response = await fetch('/api/ai/summarize', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...(authToken ? { 'Authorization': `Bearer ${authToken}` } : {})
          },
          body: JSON.stringify({ text })
        });

        const data = await response.json();

        if (data.success) {
          document.getElementById('summarizeOriginal').textContent = text;
          document.getElementById('summarizeResult').textContent = data.summary;
          document.getElementById('summarizeModal').classList.add('active');
          log('Text summarized successfully');
          
          // Refresh user stats to update AI usage
          if (authToken) {
            loadUserStats();
          }
        } else {
          showError(data.error || 'Failed to summarize text', resultAreaId);
          log('Summarize error: ' + (data.error || 'Unknown error'));
        }
      } catch (error) {
        showError('Network error: ' + error.message, resultAreaId);
        log('Summarize network error: ' + error.message);
      } finally {
        setButtonLoading(button, false);
      }
    }

    async function formatText(resultAreaId, platform) {
      const text = getTranscriptText(resultAreaId);
      if (!text || text.length < 10) {
        showError('Please transcribe some audio first', resultAreaId);
        return;
      }

      const button = event.target;
      setButtonLoading(button, true);

      try {
        const response = await fetch('/api/ai/format', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...(authToken ? { 'Authorization': `Bearer ${authToken}` } : {})
          },
          body: JSON.stringify({ text, platform })
        });

        const data = await response.json();

        if (data.success) {
          document.getElementById('formatOriginal').textContent = text;
          document.getElementById('formatResult').textContent = data.formattedText;
          document.getElementById('formatModal').classList.add('active');
          log(`Text formatted for ${platform} successfully`);
          
          // Refresh user stats to update AI usage
          if (authToken) {
            loadUserStats();
          }
        } else {
          showError(data.error || 'Failed to format text', resultAreaId);
          log('Format error: ' + (data.error || 'Unknown error'));
        }
      } catch (error) {
        showError('Network error: ' + error.message, resultAreaId);
        log('Format network error: ' + error.message);
      } finally {
        setButtonLoading(button, false);
      }
    }

    async function formatAllText(resultAreaId) {
      const text = getTranscriptText(resultAreaId);
      if (!text || text.length < 10) {
        showError('Please transcribe some audio first', resultAreaId);
        return;
      }

      const button = event.target;
      setButtonLoading(button, true);

      try {
        const response = await fetch('/api/ai/format-all', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...(authToken ? { 'Authorization': `Bearer ${authToken}` } : {})
          },
          body: JSON.stringify({ text })
        });

        const data = await response.json();

        if (data.success) {
          document.getElementById('formatAllOriginal').textContent = text;
          
          // Populate all platform results
          document.getElementById('facebookResult').textContent = data.formattedTexts.facebook;
          document.getElementById('whatsappResult').textContent = data.formattedTexts.whatsapp;
          document.getElementById('xResult').textContent = data.formattedTexts.x;
          document.getElementById('instagramResult').textContent = data.formattedTexts.instagram;
          document.getElementById('telegramResult').textContent = data.formattedTexts.telegram;
          
          document.getElementById('formatAllModal').classList.add('active');
          log('Text formatted for all platforms successfully');
          
          // Refresh user stats to update AI usage
          if (authToken) {
            loadUserStats();
          }
        } else {
          showError(data.error || 'Failed to format text', resultAreaId);
          log('Format all error: ' + (data.error || 'Unknown error'));
        }
      } catch (error) {
        showError('Network error: ' + error.message, resultAreaId);
        log('Format all network error: ' + error.message);
      } finally {
        setButtonLoading(button, false);
      }
    }

    // Modal functions
    function closeModal(modalId) {
      document.getElementById(modalId).classList.remove('active');
    }

    function showPlatform(platform) {
      // Hide all platform contents
      document.querySelectorAll('.platform-content').forEach(content => {
        content.classList.remove('active');
      });
      
      // Remove active class from all tabs
      document.querySelectorAll('.platform-tab').forEach(tab => {
        tab.classList.remove('active');
      });
      
      // Show selected platform content
      document.getElementById(platform).classList.add('active');
      
      // Add active class to clicked tab
      event.target.classList.add('active');
    }

    // Copy to clipboard function
    async function copyToClipboard(elementId) {
      const element = document.getElementById(elementId);
      const text = element.textContent;
      
      try {
        await navigator.clipboard.writeText(text);
        
        // Show feedback
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '‚úÖ Copied!';
        button.classList.add('copied');
        
        setTimeout(() => {
          button.textContent = originalText;
          button.classList.remove('copied');
        }, 2000);
        
        log('Text copied to clipboard');
      } catch (error) {
        log('Failed to copy text: ' + error.message);
        showError('Failed to copy text', 'debugLog');
      }
    }

    // Close modals when clicking outside
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('modal')) {
        e.target.classList.remove('active');
      }
    });

    // Translation Functions
    let translationRecorder = null;
    let translationChunks = [];
    let currentTranslationAudio = null;

    // Load available voices for selected language
    async function loadVoicesForLanguage(languageCode) {
      try {
        const ttsCode = getTTSCode(languageCode);
        const response = await fetch(`/api/translation/voices/${ttsCode}`, {
          headers: authToken ? { 'Authorization': `Bearer ${authToken}` } : {}
        });

        const data = await response.json();
        const voiceSelect = document.getElementById('translationVoice');
        
        if (data.success) {
          // Clear existing options except the first one
          voiceSelect.innerHTML = '<option value="">Auto-select best voice</option>';
          
          // Add voice options
          data.voices.forEach(voice => {
            const option = document.createElement('option');
            option.value = voice.name;
            option.textContent = `${voice.gender} - ${voice.name}`;
            voiceSelect.appendChild(option);
          });
          
          log(`Loaded ${data.voiceCount} voices for ${languageCode}`);
        }
      } catch (error) {
        log('Error loading voices: ' + error.message);
      }
    }

    // Get TTS language code from translation language
    function getTTSCode(languageCode) {
      const ttsMap = {
        'en': 'en-US',
        'fr': 'fr-FR',
        'ar': 'ar-XA'
      };
      return ttsMap[languageCode] || 'en-US';
    }

    // Start translation recording
    async function startTranslation() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        translationChunks = [];
        
        const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') 
          ? 'audio/webm;codecs=opus' 
          : 'audio/webm';
        
        translationRecorder = new MediaRecorder(stream, { mimeType });
        translationRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) {
            translationChunks.push(e.data);
          }
        };
        
        translationRecorder.start();
        document.getElementById('startTranslationBtn').disabled = true;
        document.getElementById('stopTranslationBtn').disabled = false;
        showLoading('Recording for translation... Click stop when done.', 'translationResult');
        log('Translation recording started');
      } catch (error) {
        showError('Microphone access denied: ' + error.message, 'translationResult');
        log('Translation recording error: ' + error.message);
      }
    }

    // Stop translation recording and process
    async function stopTranslation() {
      if (translationRecorder && translationRecorder.state === 'recording') {
        translationRecorder.stop();
        document.getElementById('startTranslationBtn').disabled = false;
        document.getElementById('stopTranslationBtn').disabled = true;
        
        translationRecorder.onstop = async () => {
          const blob = new Blob(translationChunks, { type: 'audio/webm' });
          await processTranslationAudio(blob);
        };
      }
    }

    // Process recorded audio for translation
    async function processTranslationAudio(blob) {
      showLoading('Transcribing and translating...', 'translationResult');
      log('Processing translation audio...');

      // First, transcribe the audio
      const formData = new FormData();
      formData.append('audio', blob);
      formData.append('languageCode', 'ha-NG');
      formData.append('sampleRateHertz', '16000');

      try {
        const transcriptionResponse = await fetch('/api/stt/transcribe', {
          method: 'POST',
          headers: authToken ? { 'Authorization': `Bearer ${authToken}` } : {},
          body: formData
        });

        const transcriptionData = await transcriptionResponse.json();

        if (transcriptionResponse.ok && transcriptionData.transcript) {
          const hausaText = transcriptionData.transcript;
          const targetLanguage = document.getElementById('translationLanguage').value;
          const voiceName = document.getElementById('translationVoice').value;

          // Now translate and convert to speech
          await translateAndSpeakText(hausaText, targetLanguage, voiceName);
        } else {
          showError('Transcription failed: ' + (transcriptionData.message || 'Unknown error'), 'translationResult');
        }
      } catch (error) {
        showError('Translation processing error: ' + error.message, 'translationResult');
        log('Translation processing error: ' + error.message);
      }
    }

    // Translate text and convert to speech
    async function translateAndSpeakText(text, targetLanguage, voiceName) {
      try {
        log(`Starting translation request: text="${text}", targetLanguage="${targetLanguage}", voiceName="${voiceName}"`);
        
        const requestBody = { 
          text, 
          targetLanguage, 
          voiceName: voiceName || undefined 
        };
        
        log(`Request body: ${JSON.stringify(requestBody)}`);
        
        // Create an AbortController for timeout
        const controller = new AbortController();
        const timeoutId = setTimeout(() => {
          controller.abort();
          log('Request timed out after 30 seconds');
        }, 30000); // 30 second timeout

        const response = await fetch('/api/translation/translate-and-speak', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...(authToken ? { 'Authorization': `Bearer ${authToken}` } : {})
          },
          body: JSON.stringify(requestBody),
          signal: controller.signal
        });

        clearTimeout(timeoutId);

        log(`Response status: ${response.status} ${response.statusText}`);
        log(`Response headers: ${JSON.stringify([...response.headers.entries()])}`);

        if (!response.ok) {
          const errorText = await response.text();
          log(`Response error: ${errorText}`);
          throw new Error(`HTTP ${response.status}: ${errorText}`);
        }

        const data = await response.json();
        log(`Response data: ${JSON.stringify(data)}`);

        if (data.success) {
          // Display translation results
          document.getElementById('translationResult').innerHTML = `
            <div class="ai-result">
              <h4>üá≥üá¨ Hausa (Original):</h4>
              <div class="ai-result-text">${data.originalText}</div>
            </div>
            <div class="ai-result">
              <h4>${getLanguageFlag(data.targetLanguage)} ${data.languageName} (Translated):</h4>
              <div class="ai-result-text">${data.translatedText}</div>
            </div>
            <div class="success">Translation completed successfully! Voice: ${data.voiceUsed}</div>
          `;

          // Create audio blob from base64 data
          if (data.audioData) {
            try {
              // Convert base64 to blob
              const audioBlob = new Blob([Uint8Array.from(atob(data.audioData), c => c.charCodeAt(0))], { type: 'audio/mp3' });
              const audioUrl = URL.createObjectURL(audioBlob);
              
              // Set up audio player
              const audioElement = document.getElementById('translationAudio');
              audioElement.src = audioUrl;
              audioElement.load();
              
              // Store for download
              currentTranslationAudio = {
                ...data,
                audioBlob: audioBlob,
                audioUrl: audioUrl
              };
              
              log(`Audio created successfully: ${audioBlob.size} bytes`);
            } catch (error) {
              log(`Error creating audio: ${error.message}`);
            }
          }

          // Show audio player
          document.getElementById('translationAudioPlayer').style.display = 'block';
          
          log(`Translation successful: ${data.originalText} ‚Üí ${data.translatedText}`);
        } else {
          showError(data.error || 'Translation failed', 'translationResult');
          log('Translation error: ' + (data.error || 'Unknown error'));
        }
      } catch (error) {
        log(`Translation error details: ${error.name} - ${error.message}`);
        log(`Error stack: ${error.stack}`);
        
        if (error.name === 'AbortError') {
          showError('Translation request timed out after 30 seconds. Please try again.', 'translationResult');
        } else {
          showError('Network error: ' + error.message, 'translationResult');
        }
        log('Translation network error: ' + error.message);
      }
    }

    // Translate text input
    async function translateTextInput() {
      log('translateTextInput called');
      
      const text = document.getElementById('translationTextInput').value.trim();
      const targetLanguage = document.getElementById('translationLanguage').value;
      const voiceName = document.getElementById('translationVoice').value;

      log(`Input values: text="${text}", targetLanguage="${targetLanguage}", voiceName="${voiceName}"`);

      if (!text) {
        showError('Please enter some Hausa text', 'translationResult');
        log('No text provided for translation');
        return;
      }

      showLoading('Translating text...', 'translationResult');
      log('Calling translateAndSpeakText...');
      
      try {
        await translateAndSpeakText(text, targetLanguage, voiceName);
        log('translateAndSpeakText completed');
      } catch (error) {
        log(`Error in translateTextInput: ${error.message}`);
        showError('Translation failed: ' + error.message, 'translationResult');
      }
    }

    // Audio control functions
    function playTranslationAudio() {
      const audioElement = document.getElementById('translationAudio');
      if (audioElement && audioElement.src) {
        audioElement.play().then(() => {
          log('Audio playback started');
        }).catch(error => {
          log('Audio playback failed: ' + error.message);
          showError('Audio playback failed: ' + error.message, 'translationResult');
        });
      } else {
        log('No audio available to play');
        showError('No audio available to play', 'translationResult');
      }
    }

    function pauseTranslationAudio() {
      const audioElement = document.getElementById('translationAudio');
      if (audioElement) {
        audioElement.pause();
        log('Audio playback paused');
      }
    }

    function downloadTranslationAudio() {
      if (currentTranslationAudio && currentTranslationAudio.audioBlob) {
        try {
          const url = URL.createObjectURL(currentTranslationAudio.audioBlob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `translation_${Date.now()}.mp3`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          log('Audio download started');
        } catch (error) {
          log('Audio download failed: ' + error.message);
          showError('Audio download failed: ' + error.message, 'translationResult');
        }
      } else {
        log('No audio available to download');
        showError('No audio available to download', 'translationResult');
      }
    }

    // Get language flag emoji
    function getLanguageFlag(languageCode) {
      const flags = {
        'en': 'üá∫üá∏',
        'fr': 'üá´üá∑',
        'ar': 'üá∏üá¶'
      };
      return flags[languageCode] || 'üåç';
    }

    // Get language name from language code
    function getLanguageName(languageCode) {
      const languageNames = {
        'ha-NG': 'Hausa',
        'yo-NG': 'Yoruba',
        'ig-NG': 'Igbo',
        'ar-SA': 'Arabic',
        'en-US': 'English'
      };
      return languageNames[languageCode] || languageCode;
    }

    // Load available languages from public API
    async function loadAvailableLanguages() {
      try {
        log('Loading languages from API...');
        const response = await fetch('/api/languages/available');
        log('API response status: ' + response.status);
        
        const data = await response.json();
        log('API response data: ' + JSON.stringify(data));
        
        if (data.success) {
          // Upload form language selects
          const sourceSelect = document.getElementById('sourceLanguage');
          const targetSelect = document.getElementById('targetLanguage');
          
          // Live recording form language selects
          const recordSourceSelect = document.getElementById('recordSourceLanguage');
          const recordTargetSelect = document.getElementById('recordTargetLanguage');
          
          if (!sourceSelect || !targetSelect || !recordSourceSelect || !recordTargetSelect) {
            log('Language select elements not found!');
            return;
          }
          
          // Clear existing options
          sourceSelect.innerHTML = '';
          targetSelect.innerHTML = '';
          recordSourceSelect.innerHTML = '';
          recordTargetSelect.innerHTML = '';
          
          // Add source languages
          let sourceCount = 0;
          data.languages.forEach(lang => {
            // Default to true if property is missing (for backward compatibility)
            const isSource = lang.isSourceLanguage !== undefined ? lang.isSourceLanguage : true;
            log(`Processing language: ${lang.name}, isSourceLanguage: ${isSource}`);
            if (isSource) {
              // Upload form
              const option = document.createElement('option');
              option.value = lang.code;
              option.textContent = `${lang.flag} ${lang.name}`;
              if (lang.code === 'ha-NG') option.selected = true; // Default to Hausa
              sourceSelect.appendChild(option);
              
              // Live recording form
              const recordOption = document.createElement('option');
              recordOption.value = lang.code;
              recordOption.textContent = `${lang.flag} ${lang.name}`;
              if (lang.code === 'ha-NG') recordOption.selected = true; // Default to Hausa
              recordSourceSelect.appendChild(recordOption);
              
              sourceCount++;
              log(`Added source language: ${lang.name}`);
            }
          });
          
          // Add target languages
          let targetCount = 0;
          data.languages.forEach(lang => {
            // Default to true if property is missing (for backward compatibility)
            const isTarget = lang.isTargetLanguage !== undefined ? lang.isTargetLanguage : true;
            log(`Processing language: ${lang.name}, isTargetLanguage: ${isTarget}`);
            if (isTarget) {
              // Upload form
              const option = document.createElement('option');
              option.value = lang.code;
              option.textContent = `${lang.flag} ${lang.name}`;
              if (lang.code === 'ha-NG') option.selected = true; // Default to Hausa
              targetSelect.appendChild(option);
              
              // Live recording form
              const recordOption = document.createElement('option');
              recordOption.value = lang.code;
              recordOption.textContent = `${lang.flag} ${lang.name}`;
              if (lang.code === 'ha-NG') recordOption.selected = true; // Default to Hausa
              recordTargetSelect.appendChild(recordOption);
              
              targetCount++;
              log(`Added target language: ${lang.name}`);
            }
          });
          
          log(`Added ${sourceCount} source languages and ${targetCount} target languages to both forms`);
          
          log(`Successfully loaded ${data.languages.length} languages from API`);
        } else {
          log('API returned success: false - ' + (data.error || 'Unknown error'));
        }
      } catch (error) {
        log('Error loading languages from API: ' + error.message);
        log('Error details: ' + error.stack);
        // Fallback to default languages if API fails
        loadDefaultLanguages();
      }
    }

    // Fallback function to load default languages
    function loadDefaultLanguages() {
      log('Loading default languages as fallback...');
      
      const defaultLanguages = [
        { code: 'ha-NG', name: 'Hausa', flag: 'üá≥üá¨', isSourceLanguage: true, isTargetLanguage: true },
        { code: 'yo-NG', name: 'Yoruba', flag: 'üá≥üá¨', isSourceLanguage: true, isTargetLanguage: true },
        { code: 'ig-NG', name: 'Igbo', flag: 'üá≥üá¨', isSourceLanguage: true, isTargetLanguage: true },
        { code: 'ar-SA', name: 'Arabic', flag: 'üá∏üá¶', isSourceLanguage: true, isTargetLanguage: true },
        { code: 'en-US', name: 'English', flag: 'üá∫üá∏', isSourceLanguage: false, isTargetLanguage: true }
      ];
      
      const sourceSelect = document.getElementById('sourceLanguage');
      const targetSelect = document.getElementById('targetLanguage');
      const recordSourceSelect = document.getElementById('recordSourceLanguage');
      const recordTargetSelect = document.getElementById('recordTargetLanguage');
      
      if (!sourceSelect || !targetSelect || !recordSourceSelect || !recordTargetSelect) {
        log('Language select elements not found in fallback!');
        return;
      }
      
      // Clear existing options
      sourceSelect.innerHTML = '';
      targetSelect.innerHTML = '';
      recordSourceSelect.innerHTML = '';
      recordTargetSelect.innerHTML = '';
      
      // Add source languages
      defaultLanguages.forEach(lang => {
        if (lang.isSourceLanguage) {
          // Upload form
          const option = document.createElement('option');
          option.value = lang.code;
          option.textContent = `${lang.flag} ${lang.name}`;
          if (lang.code === 'ha-NG') option.selected = true; // Default to Hausa
          sourceSelect.appendChild(option);
          
          // Live recording form
          const recordOption = document.createElement('option');
          recordOption.value = lang.code;
          recordOption.textContent = `${lang.flag} ${lang.name}`;
          if (lang.code === 'ha-NG') recordOption.selected = true; // Default to Hausa
          recordSourceSelect.appendChild(recordOption);
        }
      });
      
      // Add target languages
      defaultLanguages.forEach(lang => {
        if (lang.isTargetLanguage) {
          // Upload form
          const option = document.createElement('option');
          option.value = lang.code;
          option.textContent = `${lang.flag} ${lang.name}`;
          if (lang.code === 'ha-NG') option.selected = true; // Default to Hausa
          targetSelect.appendChild(option);
          
          // Live recording form
          const recordOption = document.createElement('option');
          recordOption.value = lang.code;
          recordOption.textContent = `${lang.flag} ${lang.name}`;
          if (lang.code === 'ha-NG') recordOption.selected = true; // Default to Hausa
          recordTargetSelect.appendChild(recordOption);
        }
      });
      
      log('Default languages loaded successfully');
    }

    // Initialize the app
    document.addEventListener('DOMContentLoaded', () => {
      try {
        setupFileUpload();
        loadAuthState(); // Load saved authentication state
        loadAvailableLanguages(); // Load languages from admin API
        log('App initialized');
        
        // Test if JavaScript is working
        console.log('Hausa Speech-to-Text App loaded successfully');
        
        // Add event listeners
        document.getElementById('loginTab').addEventListener('click', () => showAuthForm('login'));
        document.getElementById('registerTab').addEventListener('click', () => showAuthForm('register'));
        document.getElementById('loginFormElement').addEventListener('submit', handleLogin);
        document.getElementById('registerFormElement').addEventListener('submit', handleRegister);
        document.getElementById('logoutBtn').addEventListener('click', logout);
        document.getElementById('recordBtn').addEventListener('click', startRecording);
        document.getElementById('stopBtn').addEventListener('click', stopRecording);
        document.getElementById('connectBtn').addEventListener('click', connectWebSocket);
        document.getElementById('disconnectBtn').addEventListener('click', disconnectWebSocket);
        document.getElementById('startMicBtn').addEventListener('click', startMicStream);
        document.getElementById('stopMicBtn').addEventListener('click', stopMicStream);
        document.getElementById('endSessionBtn').addEventListener('click', endSession);
        document.getElementById('watchAdBtn').addEventListener('click', watchAd);
        document.getElementById('showPlansBtn').addEventListener('click', showSubscriptionTiers);
        
        // Translation event listeners
        document.getElementById('startTranslationBtn').addEventListener('click', startTranslation);
        document.getElementById('stopTranslationBtn').addEventListener('click', stopTranslation);
        document.getElementById('translateTextBtn').addEventListener('click', translateTextInput);
        
        // Load voices when language changes
        document.getElementById('translationLanguage').addEventListener('change', (e) => {
          loadVoicesForLanguage(e.target.value);
        });
        
        // Load initial voices for English
        loadVoicesForLanguage('en');
        
        // Test form elements exist
        const loginForm = document.getElementById('loginForm');
        const registerForm = document.getElementById('registerForm');
        console.log('Login form found:', !!loginForm);
        console.log('Register form found:', !!registerForm);
        
      } catch (error) {
        console.error('Error initializing app:', error);
        log('Error initializing app: ' + error.message);
      }
    });
  </script>
</body>
</html>

